<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA+集合]]></title>
    <url>%2F2018%2F06%2F16%2FJAVA%2B%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[JAVA集合框架主要包括两种类型的容器，一种是单列集合（Collection），存储一个元素集合；另一种是双列集合（Map），存储键/值对映射。JAVA集合可以更方便的存储数据，相对于数组来说有很大的优势，集合的容量可以动态的添加，而使用数组定义后大小不可变。 总述：集合三大接口Iterator、Collection和Map；均属于java.util包下 集合与数组的区别 数组在定义后，其长度是固定的，但如果需要增大数组，需要自己编写动态数组的方法；可以存储基本类型数据，也可以存储引用类型数据。 集合的长度是可动态变化的，只能存储引用类型数据。（基本类型可以使用封装类） Collection&lt; E &gt; 简述 类型：interface; 继承：Iterable&lt; E &gt; 该接口在JDK1.2之后出现；不提供任何方法的具体实现，对象实例表示可以存储一组对象，这一组对象称为Collection的元素；其提供了单列集合共有的方法定义，Collection的具体子类有允许元素重复及不允许元素重复定义，同时Collection的具体子类有元素有序和无序之分。 Collection包括两个常用子接口：List&lt; E &gt;和Set&lt; E &gt;。 方法介绍 访问修饰符：默认（public abstract）；参数为源集合，调用者为目标集合。 添加方法 boolean add(Object o) —— 添加Object类型数据，返回添加结果。 boolean addAll(Collection&lt;? extends E&gt; c) —— 将源集合中所有元素添加至目标集合，返回添加结果。 删除方法 void clear() —— 移除集合中全部元素,无返回值。 boolean remove(Object o) —— 移除目标集合中指定元素，返回操作结果。 boolean removeAll(Collection&lt;?&gt; c) —— 移除目标集合中源集合中存在的相同元素，目标集合发生更改，返回操作结果（集合改变，返回true）。 判断方法 boolean contains(Object o) —— 判断指定元素是否存在目标集合，返回查找结果。 boolean containsAll(Collection&lt;&gt; c) —— 判断目标集合中是否包含源集合全部元素，返回查找结果。 boolean isEmpty() —— 判断目标集合是否为空，返回判断结果。 获取方法 int size() —— 得到集合的长度，返回查询的长度值。 Iterator Iterator() —— 集合的迭代器，用于集合的遍历，返回目标集合用于遍历的iterator对象。[1] Object[] toArray() —— 将目标集合所有元素转换为数组形式，返回Object类型数组 交集方法 boolean retainAll(Collection c)————仅保留两个集合中重复的元素至目标集合中，目标集合发生改变，返回true。 代码演示 Collection接口方法的使用(因为是接口，实例化必须使用其实现子类。) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void main(String[] args)&#123; //创建集合对象，接口不能实例化，需要使用其子实现类实例化 Collection&lt;Student&gt; coll = new ArrayList&lt;&gt;(); Collection&lt;Student&gt; c = new ArrayList&lt;&gt;(); //创建要添加的元素 Student s1 = new Student(&quot;张三&quot;,12); Student s2 = new Student(&quot;李四&quot;,15); Student s3 = new Student(&quot;王五&quot;,19); //向集合中添加元素 coll.add(s1); coll.add(s2); coll.add(s3); c.add(s1); c.add(s2); //向集合中添加一个集合 coll.addAll(c); //移除集合中指定的单个实例 coll.remove(s1); //移除集合中与参数集合中所有相同的元素 coll.removeAll(c); //移除集合中所有的元素 c.clear(); c.add(s3); System.out.println(&quot;判断元素s1是否存在集合coll中：&quot; + coll.contains(s1)); System.out.println(&quot;判断参数集合中元素是否为调用集合元素的子集：&quot; + coll.containsAll(c)); System.out.println(&quot;判断集合是否为空：&quot; + coll.isEmpty()); //将集合对象转为一个数组 Object[] o = coll.toArray(); Student s = (Student)o[0]; System.out.println(s.getName()+ &quot;---&quot; + s.getAge()); //获取集合的大小 System.out.println(&quot;该集合共有元素：&quot; + coll.size()); //保留两个集合的交集元素,保留元素存放在调用集合中 coll.retainAll(c); //使用Iterator方法遍历集合 Iterator&lt;Student&gt; i = c.iterator(); while(i.hasNext())&#123; Student ss = new Student(); ss = i.next(); System.out.println(ss.getName() + &quot;---&quot; + ss.getAge()); &#125;&#125;/*输出结果(需要一个Student实体类)： 判断元素s1是否存在集合coll中：false 判断参数集合中元素是否为调用集合元素的子集：true 判断集合是否为空：false 王五---19 该集合共有元素：1 王五---19*/ 以上是对单列集合接口的介绍，同时它为其单列集合的父类，定义的方法，在之后子类中均需要实现。那么接下来就介绍其常用子接口与子类。 List&lt; E &gt; 简述 类型：interface；继承：Collection&lt; E &gt; 该类型集合元素可以重复，有序；用户可以对元素的插入位置精确的控制，也可以通过整数索引访问元素。 常用实现子类：ArrayList&lt; E &gt;、LinkedList&lt; E &gt;和Vector&lt; E &gt;。 List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器。（这就是上面所说的Iterator迭代器）[1] 方法介绍 这里只介绍新增及改进的方法定义。 添加方法 void add(int index,E e) —— 向目标集合指定位置添加指定元素，无返回值。 boolean addAll(Collection&lt;? extends E&gt; c) —— 添加源集合中的所有元素到目标集合的尾部，目标集合改变返回true。 boolean addAll(int index,Collection&lt;? extends E&gt; c) —— 向目标集合指定位置添加源集合的所有元素。 【注意：在向指定位置添加元素时，针对使用索引的方法，切记索引值要在集合已存在的索引范围【0 — m+1】，如果超过范围，则会运行错误。（IndexOutOfBoundExpeception）】。 获取方法 E get(int index) —— 获取集合指定位置元素，返回获取的元素。 int indexOf(Object o) —— 获取指定元素的第一次出现索引值，不存在返回-1。 int lastIndexOf(Object o) —— 获取指定元素最后出现的索引值，不存在返回-1。 List subList(int fromIndex,int toIndex) —— 获取目标集合中的子集元素，返回指定范围内的集合元素。 ListIterator listIterator() —— 获取此集合列表元素的列表迭代器（按适当顺序）。 ListIterator listIterator(int index) —— 获取列表指定位置开始元素的列表迭代器（按适当顺序）。 移除方法 E remove(int index) —— 移除目标集合中指定索引处元素，返回被移除元素。 E set(int index,E e) —— 替换目标集合中指定位置元素，返回被替换元素。 代码演示 List&lt; E &gt;也为接口类型，新增了一些方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args)&#123; //创建List实例 List&lt;Integer&gt; listOne = new ArrayList&lt;&gt;(); List&lt;Integer&gt; listTwo = new ArrayList&lt;&gt;(); //向集合中添加元素 listOne.add(1); listOne.add(3); //向集合指定位置添加元素 listOne.add(1,2); listTwo.add(4); //向集合指定位置添加另一集合的全部元素 listOne.addAll(0,listTwo); listOne.add(4); System.out.println(&quot;获取到指定索引的元素：&quot; + listOne.get(2)); System.out.println(&quot;获取指定元素第一次出现的索引值：&quot; + listOne.indexOf(4)); System.out.println(&quot;获取指定元素最后一次出现的索引值：&quot; + listOne.lastIndexOf(4)); System.out.println(&quot;移除指定索引处的元素：&quot; + listOne.remove(0)); System.out.println(&quot;替换指定索引处的元素：&quot; + listOne.set(0,4)); //获取集合指定范围的集合元素 List&lt;Integer&gt; ll = listOne.subList(1,3); System.out.println(ll); System.out.println(listOne); //List类型集合特有的遍历方法（普通for循环） for(int i = 0;i &lt; listOne.size();i++)&#123; System.out.print(listOne.get(i) + &quot;、&quot;); &#125; System.out.println(); //ListIterator的父亲是Iterator,同样也是通过内部类实现该接口中的方法 ListIterator&lt;Integer&gt; li = listOne.listIterator(); //集合元素向后输出 while(li.hasNext())&#123; System.out.print(li.next() + &quot;、&quot;); &#125; System.out.println(); //集合元素向前输出 while(li.hasPrevious())&#123; System.out.print(li.previous() + &quot;、&quot;); &#125;&#125;/*输出结果： 获取到指定索引的元素：2 获取指定元素第一次出现的索引值：0 获取指定元素最后一次出现的索引值：4 移除指定索引处的元素：4 替换指定索引处的元素：1 [2, 3] [4, 2, 3, 4] 4、2、3、4、 4、2、3、4、 4、3、2、4、*/ 该集合类型允许元素重复，同时保证数据元素是有序的，元素可以为null。 ArrayList&lt; E &gt; 简述 类型：实体类；继承：AbstractList&lt; E &gt; AbstractList&lt; E &gt;：类型：抽象类；继承：AbstractCollection&lt; E &gt;；实现：List&lt; E &gt; AbstractList&lt; E &gt;抽象类实现了部分List&lt; E &gt;接口的方法。 该类型集合插入、删除操作慢，查找快，线程不安全，效率高；内部是使用动态数组实现，初始容量大小为10，集合容量可以动态扩充，通过方法：Arrays.copyOf(oldArray,newArrayLength)实现的扩充方法。 方法介绍 仅介绍新增方法 获取方法 Object clone() —— 克隆一个与目标集合相同的集合对象，返回克隆的对象。 调整方法 void trimToSize() —— 将目标集合的容量调整为列表的大小，无返回值。 代码演示 ArrayList&lt; E &gt;具体实现类，底层通过数组实现的集合。 1234567891011121314151617181920212223242526272829public static void main(String[] args)&#123; // JDK1.5及之前泛型前后都要写 ArrayList&lt;String&gt; arrayLists = new ArrayList&lt;&gt;(); // 创建集合实例对象 arrayLists.add(&quot;your name&quot;); // 向集合中添加第一个元素 arrayLists.add(&quot;your age&quot;); // 添加第二个元素 arrayLists.add(1, &quot;your sex&quot;); // 添加第三个元素 String e = arrayLists.get(2); // 得到集合中索引为2的元素 int index = arrayLists.indexOf(&quot;your age&quot;); // 得到指定元素的索引值 boolean empty = arrayLists.isEmpty(); // 判断集合元素是否为空 arrayLists.remove(2); // 移除集合中指定索引处的元素 arrayLists.set(1, &quot;your sweetheart&quot;); // 将集合指定索引处的元素替换 arrayLists.add(2, e); // 向指定索引处添加元素 int size = arrayLists.size(); // 得到集合的大小 boolean exist = arrayLists.contains(&quot;your age&quot;); // 判断集合中是否存在指定元素 Object[] p = arrayLists.toArray(); // 将集合转换为数组 //Object类型数组不可以强制转换为String类型数组。 System.out.println(&quot;取出下标为2的元素：&quot; + e + &quot;；取出元素为“your age”的索引值：&quot; + index + &quot;；集合是否为空：&quot; + empty); System.out.println(&quot;最后该集合的大小为：&quot; + size + &quot;；集合中是否存在元素“your age”：&quot; + exist); System.out.print(&quot;集合中的数据：&quot;); //普通for循环遍历集合 for (Object o : p) &#123; System.out.print(o.toString() + &quot;, &quot;); &#125;&#125; /*输出结果： 取出下标为2的元素：your age；取出元素为“your age”的索引值：2；集合是否为空：false 最后该集合的大小为：3；集合中是否存在元素“your age”：true 集合中的数据：your name, your sweetheart, your age, */ Vector&lt; E &gt; 简述 类型：实体类；继承：AbstractList&lt; E &gt;； 实现：List&lt; E &gt;, RandomAccess, Cloneable, java.io.Serializable 该类型集合插入、删除慢，查找快；线程安全，效率低；内部也是使用动态数组实现。使用比较少，基本使用方法与ArrayList一致；不过因为Vector出现比较早，在1.0版本，而Collection是在1.2中出现，所以Vector又有一些独立的方法。 方法介绍 Vector集合特有方法 添加方法 void addElement(Object o) —— 添加元素至目标集合中。 获取方法 E elementAt(int index) —— 获取目标集合中指定索引处的元素，返回查找元素。 Enumeration elements() —— 获取目标集合对象中的全部元素，返回全部元素的Enumeration对象。 代码演示 Vector&lt; E &gt;是一种线程安全的，基于数组实现的集合，全部方法均为：synchronized 123456789101112131415161718192021public static void main(String[] args)&#123; //其添加元素，获取元素的方法在之后的其他集合类型中均进行了改进。 Vector&lt;String&gt; v = new Vector&lt;&gt;(); //使用Vector特有的添加方法添加元素 v.addElement(&quot;name&quot;); v.addElement(&quot;age&quot;); //获取指定索引处的元素 System.out.println(v.elementAt(0)); //使用特有的方法遍历集合 Enumeration&lt;String&gt; en = v.elements(); while(en.hasMoreElements())&#123; System.out.println(en.nextElement()); &#125;&#125;/*输出结果： name name age*/ LinkedList&lt; E &gt; 简述 类型：实体类；继承：AbstractSequentialList&lt; E &gt;； 实现：List&lt; E &gt;, Deque&lt; E &gt;, Cloneable, java.io.Serializable 该类型集合插入，删除快，查找慢；内部数据结构是使用双向链表。 方法介绍 仅介绍新增特有方法 (因集合结构是链表类型，故可以更方便的对表头，表尾进行操作。) 添加方法 void addFirst(E e) —— 将元素添加至目标集合的首部，无返回值。 void addLast(E e) —— 将元素添加至目标集合最后一个元素后面（与add方法功能一致） 获取方法 E getFirst() —— 得到目标集合中的第一个元素，返回获取的元素对象。 E getLast() —— 得到目标集合中的最后一个元素，并返回。 移除方法 E removeFirst() —— 移除目标集合中的第一个元素，返回被移除的元素。 E removeLast() —— 移除目标集合中的最后一个元素，返回被移除的元素。 还有一些不常用的方法，详情查看Java API。 代码演示： LinkList&lt; E &gt;使用的是链表数据结构，对于插入、删除操作非常方便，但是对于查找不方便。 12345678910111213141516171819202122232425262728public static void main(String[] args)&#123; LinkedList&lt;String&gt; ll = new LinkedList&lt;&gt;(); //添加元素 ll.addFirst(&quot;第一&quot;); ll.addFirst(&quot;第二&quot;); ll.addFirst(&quot;第三&quot;); ll.addLast(&quot;第四&quot;); //获取元素 System.out.println(&quot;获取集合的第一个元素：&quot; + ll.getFirst()); System.out.println(&quot;获取集合的最后一个元素：&quot; + ll.getLast()); //移除元素 System.out.println(&quot;移除集合中第一个元素：&quot; + ll.removeFirst()); System.out.println(&quot;移除集合中最后一个元素：&quot; + ll.removeLast()); //遍历集合 ListIterator&lt;String&gt; lit = ll.listIterator(); while(lit.hasNext())&#123; System.out.print(lit.next() + &quot;、&quot;); &#125;&#125;/*输出结果 获取集合的第一个元素：第三 获取集合的最后一个元素：第四 移除集合中第一个元素：第三 移除集合中最后一个元素：第四 第二、第一、*/ Set&lt; E &gt; 简述 类型：interface；继承：Collection&lt; E &gt; 集合元素不重复，无序，因基于Map的数据结构，元素存放至key列，故不允许插入null值。 特性：1、确定性；2、互异性；3、无序性。 常用实现子类：HashSet&lt; E &gt;和TreeSet&lt; E &gt;。 方法介绍 没有新增方法 代码演示 略… 下面对其实现子类具体介绍。 HashSet&lt; E &gt; 简述 类型：实体类；继承：AbstractSet&lt; E &gt; 实现：Set, Cloneable, java.io.Serializable 该集合底层数据结构使用哈希表，通过hashCode()和equals()两个方法保证集合元素的唯一性(从而保证了元素不允许重复。)，所以对于用户自定义的类对象，必须重写hashCode()和equals()[IDE工具可以自动生成]；通过HashMap的put()添加元素，元素存放至其Key中，故元素值不可以为null。 方法介绍 该类型集合没有新增方法，其方法均来自父类的实现及重写。 代码演示 存储元素时记住为：无序且不重复；元素不能为null。 12345678910111213141516171819202122public static void main(String[] args)&#123; //Student对象中需要重写hashCode()和equals()方法，因为添加元素并保证元素的唯一性需要通过这两个方法的返回值决定 HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;(); hs.add(new Student(&quot;张三&quot;,12)); hs.add(new Student(&quot;李四&quot;,50)); hs.add(new Student(&quot;王五&quot;,20)); hs.add(new Student(&quot;张三&quot;,19)); hs.add(new Student(&quot;张三&quot;,12)); for(Student s : hs)&#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; &#125; /*输出结果 （集合元素是无序的，并且重复对象没有添加成功， 注：如果没有重写Student的hashCode()和equals()将会出现重复元素） 李四---50 张三---12 王五---20 张三---19*/ LinkedHashSet&lt; E &gt; 简述 类型：实体类；继承：HashSet&lt; E &gt;； 实现：Set&lt; E &gt;, Cloneable, Serializable 这种集合保证元素有序且唯一，这种方式的实现是基于哈希表和链表的结合； 方法介绍 及 代码演示 没有新增方法，使用与HashSet方法的使用没有差别。 TreeSet&lt; E &gt; 简述 类型：实体类；继承：AbstractSet&lt; E &gt; 实现：NavigableSet&lt; E &gt;, Cloneable, java.io.Serializable 该类型集合底层实现是使用红黑树（自平衡二叉树），具体实现是使用的TreeMap；其集合元素无序（注：元素排列的顺序是按照排序规则进行的排序，排序方式分为：自然排序和比较器排序Comparable，具体排序实现取决于构造方法Comparator）。 方法介绍 仅介绍新增方法 获取方法 Iterator&lt; E &gt; descendingIterator() —— 返回在此 set 元素上按降序进行迭代的迭代器。 NavigableSet&lt; E &gt; descendingSet() —— 返回此 set 中所包含元素的逆序视图。 E first() —— 返回此 set 中当前第一个（最低）元素。 E last() —— 返回此 set 中当前最后一个（最高）元素。 E floor(E e) —— 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。 E higher(E e) —— 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。 E lower(E e) —— 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。 移除方法 E pollFirst() —— 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。 E pollLast() —— 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。 代码演示 TreeSet&lt; E &gt;使用时，其元素对象必须存在一种排序规则（自然排序或比较器排序）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** 该类集合的唯一性通过定义的排序规则的排序比较方法的返回值决定，返回为0，元素重复* 排序方式有两种：* 自然排序：使元素对象所属的类实现Comparable接口。* 比较器排序：使创建集合时的构造方法的实际参数接受一个Comparator子类对象* 两种排序方法均是在其重写方法中实现排序规则。*/public static void main(String[] args)&#123; // 创建集合对象，使用自然排序，在String类中实现了Comparable&lt;E&gt;接口 TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(); // 添加集合String类型元素 ts.add(&quot;第一个&quot;); ts.add(&quot;第二个&quot;); ts.add(&quot;第三个&quot;); ts.add(&quot;第一个&quot;); // Set集合不允许元素重复 for (String s : ts) &#123; System.out.println(s); &#125; System.out.println(&quot;----------------------------&quot;); /* * 存储自定义对象元素需要注意，如果存储自定义对象就必须在自定义对象类中实现Comparable&lt;E&gt;接口。 * 并实现接口中的compareTo()方法，在方法中定义需要的排序规则。 例：自定义对象有两个属性：年龄和姓名； * 设置按照年龄排序，如年龄相同再比较姓名，如果两者均相同则认为同一对象，不重复添加。 * * @Override public int compareTo(Student o) &#123; if(o == null) &#123; return 0; &#125; * if(o.getAge() != this.age) &#123; return this.age - o.getAge(); &#125; return * this.name.compareTo(o.getName()); &#125; */ TreeSet&lt;Student&gt; ts2 = new TreeSet&lt;&gt;(); ts2.add(new Student(&quot;张三&quot;, 12)); ts2.add(new Student(&quot;李四&quot;, 50)); ts2.add(new Student(&quot;王五&quot;, 20)); ts2.add(new Student(&quot;张三&quot;, 19)); ts2.add(new Student(&quot;赵六&quot;, 12)); ts2.add(new Student(&quot;张三&quot;, 12)); for (Student s : ts2) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; System.out.println(&quot;----------------------------&quot;); /* * 通过有参构造方法，使用比较器比较元素 * * public class MyComparator implements Comparator&lt;Student&gt;&#123; * @Override * public int compare(Student o1, Student o2) &#123; * if(o1 == null || o2 == null) &#123; return 0; &#125; * if(o1.getAge() != o2.getAge()) &#123; return o1.getAge() - o2.getAge(); &#125; * return o1.getName().compareTo(o2.getName()); &#125; * &#125; * &#125; */ TreeSet&lt;Student&gt; ts3 = new TreeSet&lt;Student&gt;(new MyComparator()); ts3.add(new Student(&quot;张三&quot;, 12)); ts3.add(new Student(&quot;李四&quot;, 50)); ts3.add(new Student(&quot;王五&quot;, 20)); ts3.add(new Student(&quot;张三&quot;, 19)); ts3.add(new Student(&quot;四眼&quot;, 12)); ts3.add(new Student(&quot;张三&quot;, 12)); for (Student s : ts3) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; System.out.println(&quot;----------------------------&quot;); // 参数中直接创建接口的实现内部类；实现Comparator接口的方法 TreeSet&lt;String&gt; ts1 = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; int i1 = o1.length() - o2.length(); int i2 = i1 == 0 ? o1.compareTo(o2) : i1; return i2; &#125; &#125;); ts1.add(&quot;第一个&quot;); ts1.add(&quot;第二个&quot;); ts1.add(&quot;第三个&quot;); ts1.add(&quot;第四个&quot;); for (String s : ts1) &#123; System.out.println(s); &#125;&#125;/*输出结果 第一个 第三个 第二个 ---------------------------- 张三---12 赵六---12 张三---19 王五---20 李四---50 ---------------------------- 四眼---12 张三---12 张三---19 王五---20 李四---50 ---------------------------- 第一个 第三个 第二个 第四个*/ Collection&lt; E &gt;简单总结 Collection&lt; E &gt; 单列集合类型，只能存储引用类型数据，为接口，具体使用需要用实现子类。 下面介绍的按其继承关系排列。 List&lt; E &gt;：元素有序，可重复 ArrayList&lt; E &gt;：增删慢，查找快；底层使用数组，线程不安全，效率高 Vector&lt; E &gt;：增删满，查找快；底层使用数组，线程安全，效率低 LinkedList&lt; E &gt;：增删快，查找慢；底层使用链表 Set&lt; E &gt;：元素无序，不重复 HashSet&lt; E &gt;：集合元素有序，底层使用哈希表，依靠hashCode()和equals()方法，保证元素唯 LinkedHashSet&lt; E &gt;：底层是链表和哈希表(链表保证有序，哈希表保证唯一) TreeSet&lt; E &gt;：底层使用自平衡二叉树，有两种排序方案：自然排序(Comparable)、比较器排序(Comparator)，保证唯一依赖的是排序方法的返回值，0表示元素重复。 Map&lt;K,V &gt; 简述 类型：interface；继承：Object 该集合是一种将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。Map的数据结构与键有关，是双列结构。 该接口的常用实现子类：HashMap&lt;K,V&gt;、LinkHashMap&lt;K,V&gt;和TreeMap&lt;K,V&gt;。 方法介绍 接口仅对方法进行定义。 添加功能 V put(K key,V value) —— 添加/修改键值对元素，键如果存在则将旧值替换，不存在则直接添加元素。 void putAll(Map&lt;? extends K&gt;,&lt;? extends V&gt; m) —— 将源集合添加至目标集合。 删除功能 void clear() —— 清除目标集合中的所有键值对元素。 V remove(Object key) —— 移除指定键对应的元素，返回被移除的值，不存在返回null。 判断功能 boolean containsKey(Object key) —— 判断该键在目标集合中是否存在。 boolean containsValue(Object value) —— 判断指定的值在目标集合中是否存在。 boolean isEmpty() —— 判断该集合是否为空。 获取功能 V get(Object key) —— 得到指定键映射的值。 Collection values() —— 返回此映射中包含的值的 Collection 视图 Set keySet() —— 返回此映射中包含的键的 Set 集合视图 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() —— 返回此映射中包含映射关系的 Set 集合视图。[2] 长度功能 int size() —— 得到集合元素的大小。 代码演示 Map&lt;K,V&gt;是一种双列集合，并且其中键是唯一的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args)&#123; //创建Map集合,接口不能创建对象 Map&lt;String,String&gt; m = new HashMap&lt;&gt;(); //添加元素，如果集合中元素键已存在，新的元素值将会替换 m.put(&quot;火警&quot;,&quot;119&quot;); m.put(&quot;急救&quot;,&quot;120&quot;); m.put(&quot;匪警&quot;,&quot;110&quot;); m.put(&quot;火警&quot;,&quot;未知&quot;); m.put(null, null); //清除集合元素 //m.clear(); m.remove(&quot;火警&quot;); //判断指定键是否存在集合中 System.out.println(&quot;判断急救在集合中：&quot; + m.containsKey(&quot;急救&quot;)); System.out.println(&quot;判断120在集合中：&quot; + m.containsValue(&quot;120&quot;)); System.out.println(&quot;判断集合是否为空：&quot; + m.isEmpty()); System.out.println(&quot;得到集合的键值对数量：&quot; + m.size()); //得到指定键的值 System.out.println(&quot;获取键为匪警的值：&quot; + m.get(&quot;匪警&quot;)); //得到集合的所有键 Set&lt;String&gt; s = m.keySet(); for(String ss : s)&#123; System.out.println(ss + &quot;、&quot;); &#125; //得到集合的所有值 Collection&lt;String&gt; c = m.values(); for(String a : c)&#123; System.out.println(a); &#125; //获取集合的键值对 Set&lt;Map.Entry&lt;String,String&gt;&gt; set = m.entrySet(); for(Map.Entry&lt;String,String&gt; me : set)&#123; System.out.println(me.getKey() + &quot;---&quot; + me.getValue()); &#125; System.out.println(m);&#125;/*输出结果 判断急救在集合中：true 判断120在集合中：true 判断集合是否为空：false 得到集合的键值对数量：3 获取键为匪警的值：110 急救、 null、 匪警、 120 null 110 急救---120 null---null 匪警---110 &#123;急救=120, null=null, 匪警=110&#125;*/ HashMap&lt;K,V&gt; 简述 类型：实体类；继承：AbstractMap&lt;K,V&gt; 实现：Map&lt;K,V&gt;, Cloneable, Serializable AbstractMap&lt;K,V&gt;：类型：Abstract；实现：Map&lt;K,V&gt; 基于哈希表的 Map&lt;K,V&gt; 接口的实现。此实现允许使用 null 值和 null 键；但不保证集合的顺序，特别是它不保证该顺序恒久不变。 方法介绍 没有新增方法，均为继承与实现方法的重写。 代码演示 略… LinkedHashMap&lt;K,V&gt; 简述 类型：实现类；继承：HashMap&lt;K,V&gt; 实现： Map&lt;K,V&gt; LinkHashMap&lt;K,V&gt;是通过哈希表和链表实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链表定义了集合迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。 方法介绍 没有新增方法，均为继承与实现方法的重写。 代码演示 略… TreeMap&lt;K,V&gt; 简述 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。如果是存储自定义对象，这是就要在元素所属的类中实现自然排序接口，或者使用有参的构造方法实现比较器排序 方法介绍 很多的新增方法，但是一般不常用，需要了解，查看JAVA API 代码演示 TreeMap&lt;K,V&gt;是基于二叉树的数据结构存储元素集合。 1234567891011121314151617181920212223242526static void treeMaps()&#123; TreeMap&lt;Student,Integer&gt; ts = new TreeMap&lt;&gt;(); ts.put(new Student(&quot;张三&quot;,15),101); ts.put(new Student(&quot;李四&quot;,10),102); ts.put(new Student(&quot;王五&quot;,46),103); ts.put(new Student(&quot;张三&quot;,45),104); ts.put(new Student(&quot;赵六&quot;,85),105); Set&lt;Map.Entry&lt;Student,Integer&gt;&gt; s = ts.entrySet(); for(Map.Entry&lt;Student,Integer&gt; m : s)&#123; Student st = m.getKey(); System.out.println(st.getName()+ &quot;---&quot; + st.getAge()+ &quot;---&quot;+ m.getValue()); &#125; //通过键获取一个键-值映射关系 Map.Entry&lt;Student,Integer&gt; en = ts.ceilingEntry(new Student(&quot;张三&quot;,15)); System.out.println(en.getKey().getName()+en.getValue());&#125;/*输出结果 李四---10---102 张三---15---101 张三---45---104 王五---46---103 赵六---85---105 张三101*/ Map&lt;K,V&gt;简单总结 Map&lt;K,V&gt; 这是双列集合，采用键值对的方式，数据结构与键有关，与值无关。 HashMap&lt;K,V&gt;：采用哈希表保证元素的唯一性，但是集合元素不保证有序，必须实现hashCode()和equals()。 -LinkedHashMap&lt;K,V&gt;：采用链表加哈希表的数据结构，用链表保证有序，哈希表保证元素唯一。 TreeMap&lt;K,V&gt;：采用红黑树数据结构保证元素的唯一性；该种集合，元素对象所属类需要实现Comparable接口或集合构造方法参数是一个比较器排序的对象Comparator。 Collections集合工具 简述 类名：Collections； 作用：此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。 方法：Collections该类提供了静态方法。 方法介绍 集合对象直接使用静态方法。 void sort(List list) —— 默认情况是自然排序，集合元素所属的类必须实现自然排序接口才可以使用此方法。 int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) —— 使用二分搜索法搜索指定列表，以获得指定对象。 void swap(List&lt;?&gt; list, int i, int j) —— 在指定列表的指定位置处交换元素。 Collection synchronizedCollection(Collection c) —— 返回指定 collection 支持的同步（线程安全的）collection。 还有其他获取同步类型的集合… boolean replaceAll(List list, T oldVal, T newVal) —— 使用另一个值替换列表中出现的所有某一指定值。 max(Collecton&lt;&lt;? extends T&gt; coll) —— 根据元素的自然顺序，返回给定 collection 的最大元素。 void reverse(List&lt;?&gt; list) —— 反转指定列表中元素的顺序。 void shuffle(List&lt;?&gt; list) —— 使用默认随机源对指定列表进行置换。 还有更多的方法可以方便的对集合对象操作 小结 Collections工具类可以方便的对集合元素操作。 例如：元素的替换、集合的排序、元素的查找等 更多 Java__集合 方法学习参考 JAVA API Iterator对象： 方法：boolean hasNext()，E next()，void remove()。 hasNext()：如果迭代后面仍有元素，返回true。 next()：返回迭代的下一个元素，并同时指向下一个元素。 remove()：从集合中移除迭代器返的最后一个元素,每调用一次next仅可以用一次该方法。 Iterator接口方法是在实现类中通过内部类实现，以此来针对不同的数据组织形式，编写hasNext(),next()和remove()方法。 迭代器是依赖于集合存在的，如果在使用迭代器的时候，使用集合方法修改元素，这时迭代器并不能发现集合元素的变化，所以就会报错： 【ConcurrentModificationException：当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。】 A: 有时就是需要在遍历时添加元素，这时就需要解决这种异常错误，有两种方法； 在使用迭代器遍历时，用迭代器提供的方法修改元素，但是在Iterator中并没有提供添加元素的方法，这就需要用到ListIterator接口提供的方法（注意：只有在List集合中存在该接口）。 B: 使用集合遍历元素，利用集合提供的方法修改元素（普通for循环方式）。 不允许既使用迭代器又使用集合。 ↩ ↩ Map.Entry&lt;K,V&gt;：这是一种键值对实体对象，提供了获取键和值的方法：getKey()、getValue()，在对集合进行键值对遍历时可以使用这种方法，也可以使用键找值的方法遍历。 ↩]]></content>
      <categories>
        <category>以梦为马</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>Collection</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+github+git搭建博客及MD语法]]></title>
    <url>%2F2018%2F03%2F28%2Fgithub_HEXO%2F</url>
    <content type="text"><![CDATA[欢迎使用 Hexo ，这里有更多的 文档 信息。在使用Hexo时遇到任何问题， 寻找问题答案可以到 这里 或者向他咨询 GitHub。 HEXO使用的基本方法 创建一篇文章 1$ hexo new "My New Post Name" 更多信息: Writing 本地运行服务器 1$ hexo server 更多信息: Server 本地运行服务器同时为调试模式 1$ hexo server --debug 生成静态文件 1$ hexo generate 更多信息: Generating 部署到远程站点 1$ hexo deploy 更多信息: Deployment 文章语法（标题，水平线，商标，引用，列表） 标题的使用 代码及效果 123456# h1 Heading## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading 由于标题一和标题二会产生目录，故不演示效果。 h3 Heading h4 Heading h5 Heading h6 Heading 水平线的使用 代码及效果 123*** 水平线--- 水平线___ 水平线 商标符号的使用 代码及效果 12(c) (C) (r) (R) (tm) (TM) (p) (P) +-?????? !!!! -- --- ,, © © ® ® ™ ™ § § ± ??? !!! – — , 引用文字的使用 代码及效果 123&gt; 引用一&gt;&gt; 引用二&gt;&gt;&gt; 引用三 引用一 引用二 引用三 列表的使用 代码及效果 12345678910111. 列表12. 列表2 1. 子列表1 2. 子列表2 1. 孙列表13. 列表3+ 无序列表 + 子无序列表 + 孙无序列表+ 无序列表 列表1 列表2 子列表1 子列表2 孙列表1 列表3 无序列表 子无序列表 孙无序列表 无序列表 文章语法（代码段，表格，链接，标记，自定列表） 代码段的使用 代码及效果 12345678文字段中的代码：`System.out.println(&quot;Hello World&quot;);` 代码段使用``` public void main(String[] arge)&#123; System.out.println(&quot;Hello World&quot;);&#125;``` 每行的空格数为4个以后：后面的文字自动转化为代码形式 文字段中的代码：System.out.println(&quot;Hello World&quot;); 代码段使用 123public void main(String[] arge)&#123; System.out.println(&quot;Hello World&quot;);&#125; 每行的空格数为4个以后：后面的文字自动转化为代码形式 表格的使用 代码及效果 1234| 表 —— 头 —— 1 | 表 —— 头 —— 2 | 表 —— 头 —— 3 || :---- | :----: | ----: || 居左 | 居中 | 居右 || 内容 | 内容 | 内容 | 表 —— 头 —— 1 表 —— 头 —— 2 表 —— 头 —— 3 居左 居中 居右 内容 内容 内容 链接的使用 代码及效果 123[文字链接](http://blog.itlzb.cn &quot;耳语心声&quot;)![图标，图片链接](http://blog.itlzb.cn/images/icon.jpg)Autoconverted link https://github.com/nodeca/pica (enabled linkify) 文字链接 Autoconverted link https://github.com/nodeca/pica (enabled linkify) 标记文字的使用 代码及效果 1234567Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup** and multiple paragraphs.[^second]: Footnote text. Footnote 1 link[1]. Footnote 2 link[2]. Inline footnote[3] definition. Duplicated footnote reference[2]. 定义列表的使用 代码及效果 123456789定义列表类型一的使用: 代码及效果文字内容定义列表类型二的使用 ~ 代码及效果文字内容 定义列表类型一的使用 代码及效果 文字内容 定义列表类型二的使用 代码及效果 文字内容 这是定义的标记文字的链接位置 Footnote can have markup and multiple paragraphs. ↩ Footnote text. ↩ ↩ Text of inline footnote ↩]]></content>
      <categories>
        <category>闲杂随笔</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>github</tag>
        <tag>Coding</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
