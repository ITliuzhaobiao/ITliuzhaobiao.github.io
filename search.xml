<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA —— 集合]]></title>
    <url>%2F2018%2F06%2F16%2FJAVA%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。JAVA集合可以更方便的存储数据，相对于数组来说有很大的优势，集合的容量可以动态的添加，而数组定义后大小不可变。 JAVA集合框架 总述：集合包括三大接口Iterator、Collection和Map；均属于java.util包下 集合与数组的区别： 数组在定义后，其长度是固定的，但如果需要增大数组，需要自己编写动态数组的实现；可以存储基本类型数据，也可以存储引用类型数据。 集合的长度是可动态变化的，只能存储引用类型数据。 Collection：方法 15+ 在JDK1.2之后出现；该接口不提供任何方法的具体实现，对象实例表示可以存储一组对象，这一组对象称为Collection的元素；一些Collection是允许元素重复的，也有不允许元素重复；一些Collection元素有序，也有无序的。 对于Collection又可以分为两个子接口List和Set： Collection接口定义的方法按照功能分类： 添加功能： boolean add(Object o)————添加任意类型数据，添加成功返回true boolean addAll(Collection c)————将一个集合中所有元素添加至集合，调用集合添加参数集合中的所有元素 删除功能： void clear()————移除集合中全部元素,没有返回值 boolean remove(Object o)————移除集合中指定元素，集合元素被移除返回true boolean removeAll(Collection c)————移除元素，调用集合移除参数集合中包含的元素，调用集合元素发生更改，返回true，参数集合不发生变化 判断功能： boolean contains(Object o)————判断指定元素是否存在，调用集合中存在参数元素，返回true boolean containsAll(Collection c)————判断集合中是否包含指定集合元素，调用集合包含参数集合中全部元素返回true boolean isEmpty()————判断该集合是否为空，集合为空返回true 获取功能： Iterator Iterator()————集合的迭代器，用于集合的遍历，返回集合用于遍历的iterator对象【a】 Object[] toArray()————将集合元素转换为数组形式，返回Object类型数组 T[] toArray(T[] t)————将集合元素返回指定类型的数组形式，返回集合所有元素的数组，集合元素可以直接存储在参数数组中（前提是参数数组必须大小与集合转化为数组大小相同，可以小于将转化为的数组，但是只有在返回的数组大小与参数数组大小一致时才存储在参数数组中），也作为返回值返回 长度功能： int size()————得到集合的长度，返回调用集合长度 交集功能： boolean retainAll(Collection c)————仅保留两个集合中重复的元素，并且将重复元素存储在调用集合中，调用集合元素发生更改返回true，参数集合不发生变化 【a】Iterator对象有三个方法：boolean hasNext()，E next()，void remove()； hasNext();如果迭代后面仍有元素，返回true next();返回迭代的下一个元素，并同时指向下一个元素 remove();从集合中移除迭代器返的最后一个元素,每调用一次next仅可以用一次该方法 Iterator接口是在具体实现类中通过内部类实现，以此来针对不同的数据组织形式，编写hasNext(),next()和remove()方法。 迭代器是依赖于集合存在的，如果在使用迭代器的时候，使用集合修改元素，，这时迭代器并不能发现集合元素的变化，所以就会报出错误【ConcurrentModificationException，当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。】但是有时就是需要在遍历时添加元素，这是我们就需要解决这种异常错误；有两种方法；A：在使用迭代器遍历时，使用迭代器提供的方法修改元素，但是在Iterator中并没有提供添加元素的方法，这就需要用到ListIterator接口提供的方法（只有在List集合中存在该接口）。B：使用集合遍历元素，利用集合提供的方法修改元素（普通for）。 只有在List类型的集合才能使用ListIterator接口；在后面有Listiterator的示例代码。不允许既使用迭代器又使用集合。 对Collection接口定义的方法代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 static void collection()&#123; //创建集合对象，接口不能实例化，需要使用其子实现类实例化 Collection&lt;Student&gt; coll = new ArrayList&lt;&gt;(); Collection&lt;Student&gt; c = new ArrayList&lt;&gt;(); //创建要添加的元素 Student s1 = new Student(&quot;张三&quot;,12); Student s2 = new Student(&quot;李四&quot;,15); Student s3 = new Student(&quot;王五&quot;,19); //向集合中添加元素 coll.add(s1); coll.add(s2); coll.add(s3); c.add(s1); c.add(s2); //向集合中添加一个集合 coll.addAll(c); //移除集合中指定的单个实例 coll.remove(s1); //移除集合中与参数集合中所有相同的元素 coll.removeAll(c); //移除集合中所有的元素 c.clear(); c.add(s3); System.out.println(&quot;判断元素s1是否存在集合coll中：&quot; + coll.contains(s1)); System.out.println(&quot;判断参数集合中元素是否为调用集合元素的子集：&quot; + coll.containsAll(c)); System.out.println(&quot;判断集合是否为空：&quot; + coll.isEmpty()); //将集合对象转为一个数组 Object[] o = coll.toArray(); Student s = (Student)o[0]; System.out.println(s.getName()+ &quot;---&quot; + s.getAge()); //获取集合的大小 System.out.println(&quot;该集合共有元素：&quot; + coll.size()); //保留两个集合的交集元素,保留元素存放在调用集合中 coll.retainAll(c); //使用Iterator方法遍历集合 Iterator&lt;Student&gt; i = c.iterator(); while(i.hasNext())&#123; Student ss = new Student(); ss = i.next(); System.out.println(ss.getName() + &quot;---&quot; + ss.getAge()); &#125;&#125;/*输出结果(需要一个Student类)： 判断元素s1是否存在集合coll中：false 判断参数集合中元素是否为调用集合元素的子集：true 判断集合是否为空：false 王五---19 该集合共有元素：1 王五---19*/ 首先学习了Collection，练习了其接口方法，掌握集合的基本使用；一些集合允许重复，一些不允许重复；一些元素有序，一些无序；那么这就与集合接口的具体实现有关系了，该接口存在两个子接口：List和Set两类。他们都包含了父类方法，同时也添加了适合自己数据结构的一些方法。 List：新增方法 10+ 允许元素重复，有序的集合，用户可以对元素的插入位置精确的控制，也可以通过整数索引访问元素； 具体常用实现类：ArrayList、LinkedList和Vector 新增方法： void add(int index,E e)————向集合指定位置添加元素 void addAll(int index,Collection&lt;? extends E&gt; c)————向集合指定位置添加集合 注意：针对使用索引的方法，切记索引值要在集合已存在的索引范围【0 ~ m+1】，如果超过范围，则会运行错误。（IndexOutOfBoundExpeception） E get(int index)————获取集合指定位置元素 int indexOf(Object o)————获取指定元素的第一次出现索引值 int lastIndexOf(Object o)————获取指定元素最后出现的索引值 E remove(int index)————移除集合指定索引处元素并返回移除元素 E set(int index,E e)————替换指定位置元素并返回被替换元素 List subList(int fromIndex,int toIndex)————获取集合指定范围内的子集合元素 ListIterator listIterator()————返回此列表元素的列表迭代器（按适当顺序） ListIterator listIterator(int index)————返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。 对于List新增方法的演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 static void list()&#123; //创建List实例 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); //向集合中添加元素 list.add(1); list.add(3); list.add(1,2); l.add(4); list.addAll(0,l); list.add(4); System.out.println(&quot;获取到指定索引的元素：&quot; + list.get(2)); System.out.println(&quot;获取指定元素第一次出现的索引值：&quot; + list.indexOf(4)); System.out.println(&quot;获取指定元素最后一次出现的索引值：&quot; + list.lastIndexOf(4)); System.out.println(&quot;移除指定索引处的元素：&quot; + list.remove(0)); System.out.println(&quot;替换指定索引处的元素：&quot; + list.set(0,4)); List&lt;Integer&gt; ll = list.subList(1,3); System.out.println(ll); System.out.println(list); //List类型集合特有的遍历方法 for(int i = 0;i &lt; list.size();i++)&#123; System.out.print(list.get(i) + &quot;、&quot;); &#125; System.out.println(); //ListIterator的父亲是Iterator,同样也是通过内部类实现该接口中的方法 ListIterator&lt;Integer&gt; li = list.listIterator(); while(li.hasNext())&#123; System.out.print(li.next() + &quot;、&quot;); &#125; System.out.println(); while(li.hasPrevious())&#123; System.out.print(li.previous() + &quot;、&quot;); &#125;&#125;/*输出结果： 获取指定元素第一次出现的索引值：0 获取指定元素最后一次出现的索引值：4 移除指定索引处的元素：4 替换指定索引处的元素：1 [2, 3] [4, 2, 3, 4] 4、2、3、4、 4、2、3、4、 4、3、2、4、*/ ArrayList：方法 20+该类型集合插入、删除慢，查找快；线程不安全，效率高；内部实现是使用的动态数组实现的，初始容量大小为10，容量可以动态扩充大小，使用的是Arrays.copyOf(oldArray,newArrayLength)方法实现的扩充方法。 在前面学习的接口所有方法，都是在其子类中具体实现， 简单示例代码： 123456789101112131415161718192021222324252627static void arrayLists()&#123; //JDK1.5及之前泛型前后都要写 List&lt;String&gt; arrayLists = new ArrayList&lt;&gt;(); //创建集合实例对象 arrayLists.add(&quot;your name&quot;); //向集合中添加第一个元素 arrayLists.add(&quot;your age&quot;); //添加第二个元素 arrayLists.add(1,&quot;your sex&quot;); //添加第三个元素 String e = arrayLists.get(2); //得到集合中索引为2的元素 int index = arrayLists.indexOf(&quot;your age&quot;); //得到指定元素的索引值 boolean empty = arrayLists.isEmpty(); //判断集合元素是否为空 arrayLists.remove(2); //移除集合中指定索引处的元素 arrayLists.set(1,&quot;your sweetheart&quot;); //将集合指定索引处的元素替换 arrayLists.add(2,e); //向指定索引处添加元素 int size = arrayLists.size(); //得到集合的大小 boolean exist = arrayLists.contains(&quot;your age&quot;); //判断集合中是否存在指定元素 Object[] p = arrayLists.toArray(); //将集合转换为数组 //Object类型数组不可以强制转换为String类型数组。 System.out.println(&quot;取出下标为2的元素：&quot; + e + &quot;；取出元素为“your age”的索引值：&quot; + index + &quot;；集合是否为空：&quot; + empty); System.out.println(&quot;最后该集合的大小为：&quot; + size + &quot;；集合中是否存在元素“your age”：&quot; + exist); System.out.print(&quot;集合中的数据：&quot;); for(Object o : p)&#123; System.out.print(o.toString() + &quot;, &quot;); &#125; /*输出结果： 取出下标为2的元素：your age；取出元素为“your age”的索引值：2；集合是否为空：false 最后该集合的大小为：3；集合中是否存在元素“your age”：true 集合中的数据：your name, your sweetheart, your age, */ Vector：方法 42+该类型集合插入、删除慢，查找快；线程安全，效率低；内部也是使用动态数组实现。对于该的集合使用比较少，基本使用方法与ArrayList一致，不过因为Vector出现在1.0版本，而Collection是在1.2中出现，所以Vector又有一些自己1.0时的方法。 特有方法： void addElement(Object o)————添加元素 E elementAt(int index)————获取集合指定索引元素 Enumeration elements()————获取集合对象中的所有项 代码演示： 12345678910111213141516171819 static void vector()&#123; Vector&lt;String&gt; v = new Vector&lt;&gt;(); //使用Vector特有的添加方法添加元素 使用add方法替代使用 v.addElement(&quot;name&quot;); v.addElement(&quot;age&quot;); //获取指定索引处的元素 使用get方法替代 System.out.println(v.elementAt(0)); //使用特有的方法遍历集合 使用iterator方法代替 Enumeration&lt;String&gt; en = v.elements(); while(en.hasMoreElements())&#123; System.out.println(en.nextElement()); &#125;&#125;输出结果： name name age LinkedList：方法 38+该类型集合插入，删除快，查找慢；内部实现是使用双向链表； 特有方法： void addFirst(E e)————将元素添加至集合首部 void addLast(E e)————将元素添加至集合的最后（与add方法功能一致） E getFirst()————得到集合中第一个元素，并返回 E getLast()————得到集合中最后一个元素，并返回 E removeFirst()————移除集合中第一个元素，并返回 E removeLast()————移除集合中最后一个元素，并返回 还有一些不常用的方法，详情查看Java API 代码演示： 1234567891011121314151617181920212223242526 static void linkedList()&#123; LinkedList&lt;String&gt; ll = new LinkedList&lt;&gt;(); //添加元素 ll.addFirst(&quot;第一&quot;); ll.addFirst(&quot;第二&quot;); ll.addFirst(&quot;第三&quot;); ll.addLast(&quot;第四&quot;); //获取元素 System.out.println(&quot;获取集合的第一个元素：&quot; + ll.getFirst()); System.out.println(&quot;获取集合的最后一个元素：&quot; + ll.getLast()); //移除元素 System.out.println(&quot;移除集合中第一个元素：&quot; + ll.removeFirst()); System.out.println(&quot;移除集合中最后一个元素：&quot; + ll.removeLast()); //遍历集合 ListIterator&lt;String&gt; lit = ll.listIterator(); while(lit.hasNext())&#123; System.out.print(lit.next() + &quot;、&quot;); &#125;&#125;输出结果： 获取集合的第一个元素：第三 获取集合的最后一个元素：第四 移除集合中第一个元素：第三 移除集合中最后一个元素：第四 第二、第一、 Set：无新增方法 这种集合不允许元素重复，集合元素也是无序的 该集合的实现类有：TreeSet和HashSet两种类型 无新增方法 代码演示：在子类中实现 HashSet：方法：8+ 底层使用哈希表，要hashCode和equals两个方法保证集合元素的唯一性，使用的是HashMap的put方法添加元素；对于自定义的一些类对象，就需要我们重写hashCode和equals方法（IDE工具可以自动生成） 代码示例 12345678910111213141516171819 static void hashSet()&#123; HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;(); hs.add(new Student(&quot;张三&quot;,12)); hs.add(new Student(&quot;李四&quot;,50)); hs.add(new Student(&quot;王五&quot;,20)); hs.add(new Student(&quot;张三&quot;,19)); hs.add(new Student(&quot;张三&quot;,12)); for(Student s : hs)&#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; &#125;//Student对象中需要重写hashCode和equals方法，因为添加元素并保证元素的唯一性需要通过这两个方法的返回值决定/*输出结果：通过输出结果可以看到，集合元素的顺序和我们输入的顺序不一致 李四---50 张三---12 王五---20 张三---19*/ LinkedHashSet:无新方法 这是一种有序并且保证集合元素唯一的类，父类是HashSet 示例代码：略（使用方法和HashSet一样） TreeSet：方法：26+ 该类型集合底层实现是使用红黑树（自平衡二叉树），其中的元素是无序的（元素是按照代码中的排序方式排序的：自然排序和比较器排序Comparable，具体实现取决于构造方法Comparator）集合的具体实现是使用的TreeMap的方法 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 /* * 集合的唯一性通过排序方法中的比较方法返回值决定的，返回为0，表示元素重复 * 排序方式有两种 * 自然排序：让元素所属的类实现Comparable接口 * 比较器排序：让集合的构造方法接受一个Comparator子类对象 * 两种排序方法在重写方法中编写排序方式 */ static void treeSet()&#123; //创建集合对象，使用自然排序，在String类中实现了Comparable&lt;E&gt;接口 TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(); //添加集合元素 ts.add(&quot;第一个&quot;); ts.add(&quot;第二个个&quot;); ts.add(&quot;啊啊&quot;); ts.add(&quot;第一个&quot;); //Set集合不允许匀速重复 for(String s : ts)&#123; System.out.println(s); &#125; System.out.println(&quot;--------------&quot;); /* * 对存储自定义对象 * 这是就需要注意了，如果使用存储自定义对象就必须在自定义对象类中实现Comparable接口 * 实现接口中的compareTo方法，在该方法中定义自己需要的排序方式 * 在自定义对象中设置的按照年龄排序，然后年龄相同在比较姓名，如果两者相同则认为同一对象 */ //使用无参构造方法 TreeSet&lt;Student&gt; ts2 = new TreeSet&lt;&gt;(); ts2.add(new Student(&quot;张三&quot;,12)); ts2.add(new Student(&quot;李四&quot;,50)); ts2.add(new Student(&quot;王五&quot;,20)); ts2.add(new Student(&quot;张三&quot;,19)); ts2.add(new Student(&quot;张三&quot;,12)); ts2.add(new Student(&quot;张三&quot;,12)); for(Student s : ts2)&#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; System.out.println(&quot;--------------&quot;); //使用比较器比较元素；使用有参构造方法 TreeSet&lt;Student&gt; ts3 = new TreeSet&lt;&gt;(new MyComparator()); ts3.add(new Student(&quot;张三&quot;,12)); ts3.add(new Student(&quot;李四&quot;,50)); ts3.add(new Student(&quot;王五&quot;,20)); ts3.add(new Student(&quot;张三&quot;,19)); ts3.add(new Student(&quot;张三&quot;,12)); ts3.add(new Student(&quot;张三&quot;,12)); for(Student s : ts2)&#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; System.out.println(&quot;----------------&quot;); //参数中直接创建接口的实现内部类；实现Comparator接口的方法 TreeSet&lt;String&gt; ts1 = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; int i1 = o1.length() - o2.length(); int i2 = i1==0?o1.compareTo(o2):i1; return i2; &#125; &#125;); ts1.add(&quot;第一个&quot;); ts1.add(&quot;第二个个&quot;); ts1.add(&quot;第三个&quot;); ts1.add(&quot;啊啊&quot;); for(String s : ts1)&#123; System.out.println(s); &#125;&#125; /*输出结果： 啊啊 第一个 第二个个 -------------- 张三---12 张三---19 王五---20 李四---50 -------------- 张三---12 张三---19 王五---20 李四---50 ---------------- 啊啊 第一个 第三个 第二个个 */ Collection集合的简单总结： Collection List：有序，可重复 ArrayList：增删慢，查找快；底层使用数组，线程不安全，效率高 Vector：增删满，查找快；底层使用数组，线程安全，效率低 LinkedList：增删快，查找慢；底层使用链表 Set：无序，不可重复 HashSet：集合元素有序，底层使用哈希表，依靠hashCode和equals方法，保证元素唯一 LinkedHashSet：底层是链表和哈希表(链表保证有序，哈希表保证唯一) TreeSet：底层使用自平衡二叉树，有两种排序方案：自然排序(Comparable)、比较器排序(Comparator)，实现该接口，保证唯一依赖的是排序方法的返回值，0表示元素重复 Map：方法 14+ 该集合是一种将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。Map的数据结构键有关，是双列结构 该接口的使用是通过HashMap和TreeMap两个实现类 Map方法按照功能分类： 添加功能： V put(K key,V value)————添加/修改一对键值对元素，返回集合之前键对应的值 void putAll(Map&lt;? extends K,? extends V&gt; m)————添加一个Map集合 删除功能： void clear()————清除集合中的所有键值对元素 V remove(Object key)————移除指定键的键值对元素 判断功能： boolean containsKey(Object key)————判断该键是否存在 boolean containsValue(Object value)————判断该值是否存在 boolean isEmpty()————判断该集合是否为空 获取功能： Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()————返回此映射中包含的映射关系的 Set 视图 V get(Object key)————得到指定键映射的值 Set keySet()————返回此映射中包含的键的 Set 视图 Collection values()————返回此映射中包含的值的 Collection 视图 长度功能： int size()————得到集合的键值对数量 Map.Entry&lt;K,V&gt;：这是一种键值对实体，提供了得到键和值的方法：getKey、getValue，在对集合进行键值对遍历时可以使用这种方法，也可以使用键找值的方法遍历 对Map接口定义的方法代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 static void maps()&#123; //创建集合 Map&lt;String,String&gt; m = new HashMap&lt;&gt;(); //添加元素，如果集合中元素键已存在，新的元素值将会替换以前键的值 m.put(&quot;火警&quot;,&quot;119&quot;); m.put(&quot;急救&quot;,&quot;120&quot;); m.put(&quot;匪警&quot;,&quot;110&quot;); m.put(&quot;火警&quot;,&quot;未知&quot;); //清除集合元素 //m.clear(); m.remove(&quot;火警&quot;); //判断指定键是否存在集合中 System.out.println(&quot;判断急救在集合中：&quot; + m.containsKey(&quot;急救&quot;)); System.out.println(&quot;判断120在集合中：&quot; + m.containsValue(&quot;120&quot;)); System.out.println(&quot;判断集合是否为空：&quot; + m.isEmpty()); System.out.println(&quot;得到集合的键值对数量：&quot; + m.size()); //得到指定键的值 System.out.println(&quot;获取键为匪警的值：&quot; + m.get(&quot;匪警&quot;)); //得到所有的键 Set&lt;String&gt; s = m.keySet(); for(String ss : s)&#123; System.out.println(ss + &quot;、&quot;); &#125; //得到所有的值 Collection&lt;String&gt; c = m.values(); for(String a : c)&#123; System.out.println(a); &#125; //获取键值对 也可以通过键找值 Set&lt;Map.Entry&lt;String,String&gt;&gt; set = m.entrySet(); for(Map.Entry&lt;String,String&gt; me : set)&#123; System.out.println(me.getKey() + &quot;---&quot; + me.getValue()); &#125; System.out.println(m);&#125;/*输出结果： 判断急救在集合中：true 判断120在集合中：true 判断集合是否为空：false 得到集合的键值对数量：2 获取键为匪警的值：110 急救、 匪警、 120 110 急救---120 匪警---110 &#123;急救=120, 匪警=110&#125;*/ HashMap：基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 使用方法与上面Map中方法一致 LinkedHashMap：Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。 TreeMap：基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。如果是存储自定义对象，这是就要在元素所属的类中实现自然排序接口，或者使用有参的构造方法实现比较器排序 新增方法： Map.Entry&lt;K,V&gt; ceilingEntry(K key)————返回一个键-值映射关系，它与大于等于给定键的最小键关联；如果不存在这样的键，则返回 null 还有很多个的新增方法，但是一般不常用 代码演示： 123456789101112131415161718192021222324 static void treeMaps()&#123; TreeMap&lt;Student,Integer&gt; ts = new TreeMap&lt;&gt;(); ts.put(new Student(&quot;张三&quot;,15),101); ts.put(new Student(&quot;李四&quot;,10),102); ts.put(new Student(&quot;王五&quot;,46),103); ts.put(new Student(&quot;张三&quot;,45),104); ts.put(new Student(&quot;赵六&quot;,85),105); Set&lt;Map.Entry&lt;Student,Integer&gt;&gt; s = ts.entrySet(); for(Map.Entry&lt;Student,Integer&gt; m : s)&#123; Student st = m.getKey(); System.out.println(st.getName()+ &quot;---&quot; + st.getAge()+ &quot;---&quot;+ m.getValue()); &#125; Map.Entry&lt;Student,Integer&gt; en = ts.ceilingEntry(new Student(&quot;张三&quot;,15)); System.out.println(en.getKey().getName()+en.getValue());&#125;/*输出结果： 李四---10---102 张三---15---101 张三---45---104 王五---46---103 赵六---85---105 张三101*/ Map集合的简单总结： Map:这是双列集合，采用键值对的方式，数据结构与键有关，与值无关 HashMap:采用哈希表保证元素的唯一性，但是元素不保证有序，需要实现hashCode和equals方法 -LinkedHashMap:采用链表和哈希表，链表保证有序，哈希表保证唯一 TreeMap:采用红黑树的数据结构保证元素的唯一性，使用该种集合，元素所属的类需要实现Comparable接口，或者该集合的构造方法参数是一个比较器排序的对象Comparator 集合工具 单列集合（Collection）和双列集合（Map）；那么还有一个集合的工具类：Collections该类提供的方法很多，都是静态方法，只列举几个常用的方法 void sort(List list)————默认情况是自然排序，集合元素所属的类必须实现自然排序接口才可以使用排序方法 int binarySearch()————二分查找 max(Collecton&lt;?&gt; c)————最大值 void reverse(List&lt;?&gt; list)————反转 void shuffle(List&lt;?&gt; list)————随机置换 更多方法参考JAVA API]]></content>
      <categories>
        <category>以梦为马</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>Collection</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+github+git搭建博客及MD语法]]></title>
    <url>%2F2018%2F03%2F28%2Fgithub_HEXO%2F</url>
    <content type="text"><![CDATA[欢迎使用 Hexo ，这里有更多的 文档 信息。在使用Hexo时遇到任何问题， 寻找问题答案可以到 这里 或者向他咨询 GitHub。 HEXO使用的基本方法 创建一篇文章 1$ hexo new "My New Post Name" 更多信息: Writing 本地运行服务器 1$ hexo server 更多信息: Server 本地运行服务器同时为调试模式 1$ hexo server --debug 生成静态文件 1$ hexo generate 更多信息: Generating 部署到远程站点 1$ hexo deploy 更多信息: Deployment 文章语法（标题，水平线，商标，引用，列表） 标题的使用 代码及效果 123456# h1 Heading## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading 由于标题一和标题二会产生目录，故不演示效果。 h3 Heading h4 Heading h5 Heading h6 Heading 水平线的使用 代码及效果 123*** 水平线--- 水平线___ 水平线 商标符号的使用 代码及效果 12(c) (C) (r) (R) (tm) (TM) (p) (P) +-?????? !!!! -- --- ,, © © ® ® ™ ™ § § ± ??? !!! – — , 引用文字的使用 代码及效果 123&gt; 引用一&gt;&gt; 引用二&gt;&gt;&gt; 引用三 引用一 引用二 引用三 列表的使用 代码及效果 12345678910111. 列表12. 列表2 1. 子列表1 2. 子列表2 1. 孙列表13. 列表3+ 无序列表 + 子无序列表 + 孙无序列表+ 无序列表 列表1 列表2 子列表1 子列表2 孙列表1 列表3 无序列表 子无序列表 孙无序列表 无序列表 文章语法（代码段，表格，链接，标记，自定列表） 代码段的使用 代码及效果 12345678文字段中的代码：`System.out.println(&quot;Hello World&quot;);` 代码段使用``` public void main(String[] arge)&#123; System.out.println(&quot;Hello World&quot;);&#125;``` 每行的空格数为4个以后：后面的文字自动转化为代码形式 文字段中的代码：System.out.println(&quot;Hello World&quot;); 代码段使用 123public void main(String[] arge)&#123; System.out.println(&quot;Hello World&quot;);&#125; 每行的空格数为4个以后：后面的文字自动转化为代码形式 表格的使用 代码及效果 1234| 表 —— 头 —— 1 | 表 —— 头 —— 2 | 表 —— 头 —— 3 || :---- | :----: | ----: || 居左 | 居中 | 居右 || 内容 | 内容 | 内容 | 表 —— 头 —— 1 表 —— 头 —— 2 表 —— 头 —— 3 居左 居中 居右 内容 内容 内容 链接的使用 代码及效果 123[文字链接](http://blog.itlzb.cn &quot;耳语心声&quot;)![图标，图片链接](http://blog.itlzb.cn/images/icon.jpg)Autoconverted link https://github.com/nodeca/pica (enabled linkify) 文字链接 Autoconverted link https://github.com/nodeca/pica (enabled linkify) 标记文字的使用 代码及效果 1234567Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup** and multiple paragraphs.[^second]: Footnote text. Footnote 1 link[1]. Footnote 2 link[2]. Inline footnote[3] definition. Duplicated footnote reference[2]. 定义列表的使用 代码及效果 123456789定义列表类型一的使用: 代码及效果文字内容定义列表类型二的使用 ~ 代码及效果文字内容 定义列表类型一的使用 代码及效果 文字内容 定义列表类型二的使用 代码及效果 文字内容 这是定义的标记文字的链接位置 Footnote can have markup and multiple paragraphs. ↩ Footnote text. ↩ ↩ Text of inline footnote ↩]]></content>
      <categories>
        <category>闲杂随笔</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>github</tag>
        <tag>Coding</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
