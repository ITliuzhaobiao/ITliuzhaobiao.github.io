<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JAVA+集合</title>
      <link href="/2018/06/16/JAVA+%E9%9B%86%E5%90%88/"/>
      <url>/2018/06/16/JAVA+%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>JAVA集合框架主要包括两种类型的容器，一种是单列集合（Collection），存储一个元素集合；另一种是双列集合（Map），存储键/值对映射。JAVA集合可以更方便的存储数据，相对于数组来说有很大的优势，集合的容量可以动态的添加，而使用数组定义后大小不可变。</p><p><strong>总述：集合三大接口Iterator、Collection和Map；均属于java.util包下</strong></p><dl><dt>集合与数组的区别</dt><dd>  <e></e></dd></dl><ul><li><p>数组在定义后，其长度是固定的，但如果需要增大数组，需要自己编写动态数组的方法；可以存储基本类型数据，也可以存储引用类型数据。</p></li><li><p>集合的长度是可动态变化的，只能存储引用类型数据。（基本类型可以使用封装类）</p></li></ul><p><img src="https://www.itlzb.cn/resources/jihekuangjitu.png" alt="集合框架导引图"></p><hr><h2 id="collection-e">Collection&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：interface; 继承：Iterable&lt; E &gt;<br>该接口在JDK1.2之后出现；不提供任何方法的具体实现，对象实例表示可以存储一组对象，这一组对象称为Collection的元素；其提供了单列集合共有的方法定义，Collection的具体子类有允许元素重复及不允许元素重复定义，同时Collection的具体子类有元素有序和无序之分。<br>Collection包括两个常用子接口：List&lt; E &gt;和Set&lt; E &gt;。</dd><dt>方法介绍</dt><dd>访问修饰符：默认（public abstract）；参数为源集合，调用者为目标集合。</dd></dl><ul><li>添加方法</li></ul><blockquote><p>boolean add(Object o) —— 添加Object类型数据，返回添加结果。<br>boolean addAll(Collection&lt;? extends E&gt; c) —— 将源集合中所有元素添加至目标集合，返回添加结果。</p></blockquote><ul><li>删除方法</li></ul><blockquote><p>void clear() —— 移除集合中全部元素,无返回值。<br>boolean remove(Object o) —— 移除目标集合中指定元素，返回操作结果。<br>boolean removeAll(Collection&lt;?&gt; c) —— 移除目标集合中源集合中存在的相同元素，目标集合发生更改，返回操作结果（集合改变，返回true）。</p></blockquote><ul><li>判断方法</li></ul><blockquote><p>boolean contains(Object o) —— 判断指定元素是否存在目标集合，返回查找结果。<br>boolean containsAll(Collection&lt;&gt; c) —— 判断目标集合中是否包含源集合全部元素，返回查找结果。<br>boolean isEmpty() —— 判断目标集合是否为空，返回判断结果。</p></blockquote><ul><li>获取方法</li></ul><blockquote><p>int size() —— 得到集合的长度，返回查询的长度值。<br>Iterator<e> Iterator() —— 集合的迭代器，用于集合的遍历，返回目标集合用于遍历的iterator对象。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><br>Object[] toArray() —— 将目标集合所有元素转换为数组形式，返回Object类型数组</e></p></blockquote><ul><li>交集方法</li></ul><blockquote><p>boolean retainAll(Collection c)————仅保留两个集合中重复的元素至目标集合中，目标集合发生改变，返回true。</p></blockquote><dl><dt>代码演示</dt><dd>Collection接口方法的使用(因为是接口，实例化必须使用其实现子类。)</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public void main(String[] args)&#123;</span><br><span class="line">//创建集合对象，接口不能实例化，需要使用其子实现类实例化</span><br><span class="line">Collection&lt;Student&gt; coll = new ArrayList&lt;&gt;();</span><br><span class="line">Collection&lt;Student&gt; c = new ArrayList&lt;&gt;();</span><br><span class="line">//创建要添加的元素</span><br><span class="line">Student s1 = new Student(&quot;张三&quot;,12);</span><br><span class="line">Student s2 = new Student(&quot;李四&quot;,15);</span><br><span class="line">Student s3 = new Student(&quot;王五&quot;,19);</span><br><span class="line">//向集合中添加元素</span><br><span class="line">coll.add(s1);</span><br><span class="line">coll.add(s2);</span><br><span class="line">coll.add(s3);</span><br><span class="line">c.add(s1);</span><br><span class="line">c.add(s2);</span><br><span class="line">//向集合中添加一个集合</span><br><span class="line">coll.addAll(c);</span><br><span class="line">//移除集合中指定的单个实例</span><br><span class="line">coll.remove(s1);</span><br><span class="line">//移除集合中与参数集合中所有相同的元素</span><br><span class="line">coll.removeAll(c);</span><br><span class="line">//移除集合中所有的元素</span><br><span class="line">c.clear();</span><br><span class="line">c.add(s3);</span><br><span class="line">System.out.println(&quot;判断元素s1是否存在集合coll中：&quot; + coll.contains(s1));</span><br><span class="line">System.out.println(&quot;判断参数集合中元素是否为调用集合元素的子集：&quot; + coll.containsAll(c));</span><br><span class="line">System.out.println(&quot;判断集合是否为空：&quot; + coll.isEmpty());</span><br><span class="line">//将集合对象转为一个数组</span><br><span class="line">Object[] o = coll.toArray();</span><br><span class="line">Student s = (Student)o[0];</span><br><span class="line">System.out.println(s.getName()+ &quot;---&quot; + s.getAge());</span><br><span class="line">//获取集合的大小</span><br><span class="line">System.out.println(&quot;该集合共有元素：&quot; + coll.size());</span><br><span class="line">//保留两个集合的交集元素,保留元素存放在调用集合中</span><br><span class="line">coll.retainAll(c);</span><br><span class="line">//使用Iterator方法遍历集合</span><br><span class="line">Iterator&lt;Student&gt; i = c.iterator();</span><br><span class="line">while(i.hasNext())&#123;</span><br><span class="line">Student ss = new Student();</span><br><span class="line">ss = i.next();</span><br><span class="line">System.out.println(ss.getName() + &quot;---&quot; + ss.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果(需要一个Student实体类)：</span><br><span class="line"></span><br><span class="line">判断元素s1是否存在集合coll中：false</span><br><span class="line">判断参数集合中元素是否为调用集合元素的子集：true</span><br><span class="line">判断集合是否为空：false</span><br><span class="line">王五---19</span><br><span class="line">该集合共有元素：1</span><br><span class="line">王五---19</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>以上是对单列集合接口的介绍，同时它为其单列集合的父类，定义的方法，在之后子类中均需要实现。那么接下来就介绍其常用子接口与子类。</p><hr><h2 id="list-e">List&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：interface；继承：Collection&lt; E &gt;<br>该类型集合元素可以<strong>重复，有序</strong>；用户可以对元素的插入位置精确的控制，也可以通过整数索引访问元素。<br>常用实现子类：<strong>ArrayList&lt; E &gt;</strong>、<strong>LinkedList&lt; E &gt;<strong>和</strong>Vector&lt; E &gt;</strong>。<br>List 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器。（这就是上面所说的Iterator迭代器）<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1]</a></sup></dd><dt>方法介绍</dt><dd>这里只介绍新增及改进的方法定义。</dd></dl><ul><li>添加方法</li></ul><blockquote><p>void add(int index,E e) —— 向目标集合指定位置添加指定元素，无返回值。<br>boolean addAll(Collection&lt;? extends E&gt; c) —— 添加源集合中的所有元素到目标集合的尾部，目标集合改变返回true。<br>boolean addAll(int index,Collection&lt;? extends E&gt; c) —— 向目标集合指定位置添加源集合的所有元素。<br>【注意：在向指定位置添加元素时，针对使用索引的方法，切记索引值要在集合已存在的索引范围【0 — m+1】，如果超过范围，则会运行错误。（IndexOutOfBoundExpeception）】。</p></blockquote><ul><li>获取方法</li></ul><blockquote><p>E get(int index) —— 获取集合指定位置元素，返回获取的元素。<br>int indexOf(Object o) —— 获取指定元素的第一次出现索引值，不存在返回-1。<br>int lastIndexOf(Object o) —— 获取指定元素最后出现的索引值，不存在返回-1。<br>List<e> subList(int fromIndex,int toIndex) —— 获取目标集合中的子集元素，返回指定范围内的集合元素。<br>ListIterator<e> listIterator() —— 获取此集合列表元素的列表迭代器（按适当顺序）。<br>ListIterator<e> listIterator(int index) —— 获取列表指定位置开始元素的列表迭代器（按适当顺序）。</e></e></e></p></blockquote><ul><li>移除方法</li></ul><blockquote><p>E remove(int index) —— 移除目标集合中指定索引处元素，返回被移除元素。<br>E set(int index,E e) —— 替换目标集合中指定位置元素，返回被替换元素。</p></blockquote><dl><dt>代码演示</dt><dd>List&lt; E &gt;也为接口类型，新增了一些方法。</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">//创建List实例</span><br><span class="line">List&lt;Integer&gt; listOne = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; listTwo = new ArrayList&lt;&gt;();</span><br><span class="line">//向集合中添加元素</span><br><span class="line">listOne.add(1);</span><br><span class="line">listOne.add(3);</span><br><span class="line">//向集合指定位置添加元素</span><br><span class="line">listOne.add(1,2);</span><br><span class="line">listTwo.add(4);</span><br><span class="line">//向集合指定位置添加另一集合的全部元素</span><br><span class="line">listOne.addAll(0,listTwo);</span><br><span class="line">listOne.add(4);</span><br><span class="line">System.out.println(&quot;获取到指定索引的元素：&quot; + listOne.get(2));</span><br><span class="line">System.out.println(&quot;获取指定元素第一次出现的索引值：&quot; + listOne.indexOf(4));</span><br><span class="line">System.out.println(&quot;获取指定元素最后一次出现的索引值：&quot; + listOne.lastIndexOf(4));</span><br><span class="line">System.out.println(&quot;移除指定索引处的元素：&quot; + listOne.remove(0));</span><br><span class="line">System.out.println(&quot;替换指定索引处的元素：&quot; + listOne.set(0,4));</span><br><span class="line">//获取集合指定范围的集合元素</span><br><span class="line">List&lt;Integer&gt; ll = listOne.subList(1,3);</span><br><span class="line">System.out.println(ll);</span><br><span class="line">System.out.println(listOne);</span><br><span class="line">//List类型集合特有的遍历方法（普通for循环）</span><br><span class="line">for(int i = 0;i &lt; listOne.size();i++)&#123;</span><br><span class="line">System.out.print(listOne.get(i) + &quot;、&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">//ListIterator的父亲是Iterator,同样也是通过内部类实现该接口中的方法</span><br><span class="line">ListIterator&lt;Integer&gt; li = listOne.listIterator();</span><br><span class="line">//集合元素向后输出</span><br><span class="line">while(li.hasNext())&#123;</span><br><span class="line">System.out.print(li.next() + &quot;、&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">//集合元素向前输出</span><br><span class="line">while(li.hasPrevious())&#123;</span><br><span class="line">System.out.print(li.previous() + &quot;、&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果：</span><br><span class="line"></span><br><span class="line">获取到指定索引的元素：2</span><br><span class="line">获取指定元素第一次出现的索引值：0</span><br><span class="line">获取指定元素最后一次出现的索引值：4</span><br><span class="line">移除指定索引处的元素：4</span><br><span class="line">替换指定索引处的元素：1</span><br><span class="line">[2, 3]</span><br><span class="line">[4, 2, 3, 4]</span><br><span class="line">4、2、3、4、</span><br><span class="line">4、2、3、4、</span><br><span class="line">4、3、2、4、</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>该集合类型允许元素重复，同时保证数据元素是有序的，<strong>元素可以为null</strong>。</p><h2 id="arraylist-e">ArrayList&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：实体类；继承：AbstractList&lt; E &gt;<br>AbstractList&lt; E &gt;：类型：抽象类；继承：AbstractCollection&lt; E &gt;；实现：List&lt; E &gt;AbstractList&lt; E &gt;抽象类实现了部分List&lt; E &gt;接口的方法。<br>该类型集合插入、删除操作慢，查找快，线程不安全，效率高；内部是使用动态数组实现，初始容量大小为10，集合容量可以动态扩充，通过方法：Arrays.copyOf(oldArray,newArrayLength)实现的扩充方法。</dd><dt>方法介绍</dt><dd>仅介绍新增方法</dd></dl><ul><li>获取方法</li></ul><blockquote><p>Object clone() —— 克隆一个与目标集合相同的集合对象，返回克隆的对象。</p></blockquote><ul><li>调整方法</li></ul><blockquote><p>void trimToSize() —— 将目标集合的容量调整为列表的大小，无返回值。</p></blockquote><dl><dt>代码演示</dt><dd>ArrayList&lt; E &gt;具体实现类，底层通过数组实现的集合。</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">// JDK1.5及之前泛型前后都要写</span><br><span class="line">ArrayList&lt;String&gt; arrayLists = new ArrayList&lt;&gt;(); // 创建集合实例对象</span><br><span class="line">arrayLists.add(&quot;your name&quot;); // 向集合中添加第一个元素</span><br><span class="line">arrayLists.add(&quot;your age&quot;); // 添加第二个元素</span><br><span class="line">arrayLists.add(1, &quot;your sex&quot;); // 添加第三个元素</span><br><span class="line">String e = arrayLists.get(2); // 得到集合中索引为2的元素</span><br><span class="line">int index = arrayLists.indexOf(&quot;your age&quot;); // 得到指定元素的索引值</span><br><span class="line">boolean empty = arrayLists.isEmpty(); // 判断集合元素是否为空</span><br><span class="line">arrayLists.remove(2); // 移除集合中指定索引处的元素</span><br><span class="line">arrayLists.set(1, &quot;your sweetheart&quot;); // 将集合指定索引处的元素替换</span><br><span class="line">arrayLists.add(2, e); // 向指定索引处添加元素</span><br><span class="line">int size = arrayLists.size(); // 得到集合的大小</span><br><span class="line">boolean exist = arrayLists.contains(&quot;your age&quot;); // 判断集合中是否存在指定元素</span><br><span class="line">Object[] p = arrayLists.toArray(); // 将集合转换为数组 //Object类型数组不可以强制转换为String类型数组。</span><br><span class="line">System.out.println(&quot;取出下标为2的元素：&quot; + e + &quot;；取出元素为“your age”的索引值：&quot; + index + &quot;；集合是否为空：&quot; + empty);</span><br><span class="line">System.out.println(&quot;最后该集合的大小为：&quot; + size + &quot;；集合中是否存在元素“your age”：&quot; + exist);</span><br><span class="line">System.out.print(&quot;集合中的数据：&quot;);</span><br><span class="line">//普通for循环遍历集合</span><br><span class="line">for (Object o : p) &#123;</span><br><span class="line">System.out.print(o.toString() + &quot;,   &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果：</span><br><span class="line">取出下标为2的元素：your age；取出元素为“your age”的索引值：2；集合是否为空：false</span><br><span class="line">最后该集合的大小为：3；集合中是否存在元素“your age”：true</span><br><span class="line">集合中的数据：your name,   your sweetheart,   your age,   </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="vector-e">Vector&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：实体类；继承：AbstractList&lt; E &gt;；<br>实现：List&lt; E &gt;, RandomAccess, Cloneable, java.io.Serializable<br>该类型集合插入、删除慢，查找快；线程安全，效率低；内部也是使用动态数组实现。使用比较少，基本使用方法与ArrayList一致；不过因为Vector出现比较早，在1.0版本，而Collection是在1.2中出现，所以Vector又有一些独立的方法。</dd><dt>方法介绍</dt><dd>Vector集合特有方法</dd></dl><ul><li>添加方法</li></ul><blockquote><p>void addElement(Object o) —— 添加元素至目标集合中。</p></blockquote><ul><li>获取方法</li></ul><p>E elementAt(int index) —— 获取目标集合中指定索引处的元素，返回查找元素。Enumeration<e> elements() —— 获取目标集合对象中的全部元素，返回全部元素的Enumeration对象。</e></p><dl><dt>代码演示</dt><dd>Vector&lt; E &gt;是一种线程安全的，基于数组实现的集合，全部方法均为：synchronized</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">//其添加元素，获取元素的方法在之后的其他集合类型中均进行了改进。</span><br><span class="line">Vector&lt;String&gt; v = new Vector&lt;&gt;();</span><br><span class="line">//使用Vector特有的添加方法添加元素</span><br><span class="line">v.addElement(&quot;name&quot;);</span><br><span class="line">v.addElement(&quot;age&quot;);</span><br><span class="line">//获取指定索引处的元素</span><br><span class="line">System.out.println(v.elementAt(0));</span><br><span class="line">//使用特有的方法遍历集合</span><br><span class="line">Enumeration&lt;String&gt; en =  v.elements();</span><br><span class="line">while(en.hasMoreElements())&#123;</span><br><span class="line">System.out.println(en.nextElement());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果：</span><br><span class="line"></span><br><span class="line">    name</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="linkedlist-e">LinkedList&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：实体类；继承：AbstractSequentialList&lt; E &gt;；实现：List&lt; E &gt;, Deque&lt; E &gt;, Cloneable, java.io.Serializable<br>该类型集合插入，删除快，查找慢；内部数据结构是使用双向链表。</dd><dt>方法介绍</dt><dd>仅介绍新增特有方法<br>(因集合结构是链表类型，故可以更方便的对表头，表尾进行操作。)</dd></dl><ul><li>添加方法</li></ul><blockquote><p>void addFirst(E e) —— 将元素添加至目标集合的首部，无返回值。<br>void addLast(E e) —— 将元素添加至目标集合最后一个元素后面（与add方法功能一致）</p></blockquote><ul><li>获取方法</li></ul><blockquote><p>E getFirst() —— 得到目标集合中的第一个元素，返回获取的元素对象。<br>E getLast() —— 得到目标集合中的最后一个元素，并返回。</p></blockquote><ul><li>移除方法</li></ul><blockquote><p>E removeFirst() —— 移除目标集合中的第一个元素，返回被移除的元素。<br>E removeLast() —— 移除目标集合中的最后一个元素，返回被移除的元素。</p></blockquote><ul><li>还有一些不常用的方法，详情查看Java API。</li></ul><dl><dt>代码演示：</dt><dd>LinkList&lt; E &gt;使用的是链表数据结构，对于插入、删除操作非常方便，但是对于查找不方便。</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">LinkedList&lt;String&gt; ll = new LinkedList&lt;&gt;();</span><br><span class="line">//添加元素</span><br><span class="line">ll.addFirst(&quot;第一&quot;);</span><br><span class="line">ll.addFirst(&quot;第二&quot;);</span><br><span class="line">ll.addFirst(&quot;第三&quot;);</span><br><span class="line">ll.addLast(&quot;第四&quot;);</span><br><span class="line">//获取元素</span><br><span class="line">System.out.println(&quot;获取集合的第一个元素：&quot; + ll.getFirst());</span><br><span class="line">System.out.println(&quot;获取集合的最后一个元素：&quot; + ll.getLast());</span><br><span class="line">//移除元素</span><br><span class="line">System.out.println(&quot;移除集合中第一个元素：&quot; + ll.removeFirst());</span><br><span class="line">System.out.println(&quot;移除集合中最后一个元素：&quot; + ll.removeLast());</span><br><span class="line">//遍历集合</span><br><span class="line">ListIterator&lt;String&gt; lit = ll.listIterator();</span><br><span class="line">while(lit.hasNext())&#123;</span><br><span class="line">System.out.print(lit.next() + &quot;、&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果</span><br><span class="line"></span><br><span class="line">    获取集合的第一个元素：第三</span><br><span class="line">    获取集合的最后一个元素：第四</span><br><span class="line">    移除集合中第一个元素：第三</span><br><span class="line">    移除集合中最后一个元素：第四</span><br><span class="line">    第二、第一、</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="set-e">Set&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：interface；继承：Collection&lt; E &gt;<br>集合元素<strong>不重复，无序</strong>，因基于Map的数据结构，元素存放至key列，故不允许<strong>插入null值</strong>。<br>特性：1、确定性；2、互异性；3、无序性。<br>常用实现子类：<strong>HashSet&lt; E &gt;<strong>和</strong>TreeSet&lt; E &gt;</strong>。</dd><dt>方法介绍</dt><dd>没有新增方法</dd><dt>代码演示</dt><dd>略…</dd></dl><h3 id="下面对其实现子类具体介绍">下面对其实现子类具体介绍。</h3><h2 id="hashset-e">HashSet&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：实体类；继承：AbstractSet&lt; E &gt;<br>实现：Set<e>, Cloneable, java.io.Serializable<br>该集合底层数据结构使用哈希表，通过hashCode()和equals()两个方法保证集合元素的唯一性(从而保证了元素不允许重复。)，所以对于用户自定义的类对象，<strong>必须重写hashCode()和equals()</strong>[IDE工具可以自动生成]；通过HashMap的put()添加元素，元素存放至其Key中，故元素值不可以为null。</e></dd><dt>方法介绍</dt><dd>该类型集合没有新增方法，其方法均来自父类的实现及重写。</dd><dt>代码演示</dt><dd>存储元素时记住为：无序且不重复；元素不能为null。</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"> //Student对象中需要重写hashCode()和equals()方法，因为添加元素并保证元素的唯一性需要通过这两个方法的返回值决定</span><br><span class="line">HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;();</span><br><span class="line">hs.add(new Student(&quot;张三&quot;,12));</span><br><span class="line">hs.add(new Student(&quot;李四&quot;,50));</span><br><span class="line">hs.add(new Student(&quot;王五&quot;,20));</span><br><span class="line">hs.add(new Student(&quot;张三&quot;,19));</span><br><span class="line">hs.add(new Student(&quot;张三&quot;,12));</span><br><span class="line">for(Student s : hs)&#123;</span><br><span class="line">System.out.println(s.getName() + &quot;---&quot; + s.getAge());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /*输出结果</span><br><span class="line">（集合元素是无序的，并且重复对象没有添加成功，</span><br><span class="line">  注：如果没有重写Student的hashCode()和equals()将会出现重复元素）</span><br><span class="line"></span><br><span class="line"> 李四---50</span><br><span class="line">     张三---12</span><br><span class="line">     王五---20</span><br><span class="line">     张三---19</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="linkedhashset-e">LinkedHashSet&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：实体类；继承：HashSet&lt; E &gt;；实现：Set&lt; E &gt;, Cloneable, Serializable<br>这种集合保证<strong>元素有序且唯一</strong>，这种方式的实现是基于哈希表和链表的结合；</dd><dt>方法介绍 及 代码演示</dt><dd>没有新增方法，使用与HashSet方法的使用没有差别。</dd></dl><h2 id="treeset-e">TreeSet&lt; E &gt;</h2><dl><dt>简述</dt><dd>类型：实体类；继承：AbstractSet&lt; E &gt;<br>实现：NavigableSet&lt; E &gt;, Cloneable, java.io.Serializable<br>该类型集合底层实现是使用红黑树（自平衡二叉树），具体实现是使用的TreeMap；其集合元素无序（注：元素排列的顺序是按照排序规则进行的排序，排序方式分为：<strong>自然排序和比较器排序Comparable<e></e></strong>，具体排序实现取决于构造方法Comparator<e>）。</e></dd><dt>方法介绍</dt><dd>仅介绍新增方法</dd></dl><ul><li>获取方法</li></ul><blockquote><p>Iterator&lt; E &gt; descendingIterator() —— 返回在此 set 元素上按降序进行迭代的迭代器。<br>NavigableSet&lt; E &gt; descendingSet() —— 返回此 set 中所包含元素的逆序视图。<br>E first() —— 返回此 set 中当前第一个（最低）元素。<br>E last() —— 返回此 set 中当前最后一个（最高）元素。<br>E floor(E e) —— 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。<br>E higher(E e) —— 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。<br>E lower(E e) —— 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</p></blockquote><ul><li>移除方法</li></ul><blockquote><p>E pollFirst() —— 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。<br>E pollLast() —— 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</p></blockquote><dl><dt>代码演示</dt><dd>TreeSet&lt; E &gt;使用时，其元素对象必须存在一种排序规则（自然排序或比较器排序）。</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 该类集合的唯一性通过定义的排序规则的排序比较方法的返回值决定，返回为0，元素重复</span><br><span class="line">* 排序方式有两种：</span><br><span class="line">*     自然排序：使元素对象所属的类实现Comparable接口。</span><br><span class="line">*     比较器排序：使创建集合时的构造方法的实际参数接受一个Comparator子类对象</span><br><span class="line">* 两种排序方法均是在其重写方法中实现排序规则。</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"> // 创建集合对象，使用自然排序，在String类中实现了Comparable&lt;E&gt;接口</span><br><span class="line">TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;();</span><br><span class="line">// 添加集合String类型元素</span><br><span class="line">ts.add(&quot;第一个&quot;);</span><br><span class="line">ts.add(&quot;第二个&quot;);</span><br><span class="line">ts.add(&quot;第三个&quot;);</span><br><span class="line">ts.add(&quot;第一个&quot;); // Set集合不允许元素重复</span><br><span class="line">for (String s : ts) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">/*</span><br><span class="line"> * 存储自定义对象元素需要注意，如果存储自定义对象就必须在自定义对象类中实现Comparable&lt;E&gt;接口。</span><br><span class="line"> * 并实现接口中的compareTo()方法，在方法中定义需要的排序规则。 例：自定义对象有两个属性：年龄和姓名；</span><br><span class="line"> * 设置按照年龄排序，如年龄相同再比较姓名，如果两者均相同则认为同一对象，不重复添加。</span><br><span class="line"> * </span><br><span class="line"> * @Override public int compareTo(Student o) &#123; if(o == null) &#123; return 0; &#125;</span><br><span class="line"> * if(o.getAge() != this.age) &#123; return this.age - o.getAge(); &#125; return</span><br><span class="line"> * this.name.compareTo(o.getName()); &#125;</span><br><span class="line"> */</span><br><span class="line">TreeSet&lt;Student&gt; ts2 = new TreeSet&lt;&gt;();</span><br><span class="line">ts2.add(new Student(&quot;张三&quot;, 12));</span><br><span class="line">ts2.add(new Student(&quot;李四&quot;, 50));</span><br><span class="line">ts2.add(new Student(&quot;王五&quot;, 20));</span><br><span class="line">ts2.add(new Student(&quot;张三&quot;, 19));</span><br><span class="line">ts2.add(new Student(&quot;赵六&quot;, 12));</span><br><span class="line">ts2.add(new Student(&quot;张三&quot;, 12));</span><br><span class="line">for (Student s : ts2) &#123;</span><br><span class="line">System.out.println(s.getName() + &quot;---&quot; + s.getAge());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">/*</span><br><span class="line"> * 通过有参构造方法，使用比较器比较元素</span><br><span class="line"> * </span><br><span class="line"> * public class MyComparator implements Comparator&lt;Student&gt;&#123;</span><br><span class="line"> * @Override </span><br><span class="line"> * public int compare(Student o1, Student o2) &#123; </span><br><span class="line"> * if(o1 == null || o2 == null) &#123; return 0; &#125; </span><br><span class="line"> * if(o1.getAge() != o2.getAge()) &#123; return o1.getAge() - o2.getAge(); &#125; </span><br><span class="line"> * return o1.getName().compareTo(o2.getName()); &#125; </span><br><span class="line"> * &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">TreeSet&lt;Student&gt; ts3 = new TreeSet&lt;Student&gt;(new MyComparator());</span><br><span class="line">ts3.add(new Student(&quot;张三&quot;, 12));</span><br><span class="line">ts3.add(new Student(&quot;李四&quot;, 50));</span><br><span class="line">ts3.add(new Student(&quot;王五&quot;, 20));</span><br><span class="line">ts3.add(new Student(&quot;张三&quot;, 19));</span><br><span class="line">ts3.add(new Student(&quot;四眼&quot;, 12));</span><br><span class="line">ts3.add(new Student(&quot;张三&quot;, 12));</span><br><span class="line">for (Student s : ts3) &#123;</span><br><span class="line">System.out.println(s.getName() + &quot;---&quot; + s.getAge());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">// 参数中直接创建接口的实现内部类；实现Comparator接口的方法</span><br><span class="line">TreeSet&lt;String&gt; ts1 = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(String o1, String o2) &#123;</span><br><span class="line">int i1 = o1.length() - o2.length();</span><br><span class="line">int i2 = i1 == 0 ? o1.compareTo(o2) : i1;</span><br><span class="line">return i2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ts1.add(&quot;第一个&quot;);</span><br><span class="line">ts1.add(&quot;第二个&quot;);</span><br><span class="line">ts1.add(&quot;第三个&quot;);</span><br><span class="line">ts1.add(&quot;第四个&quot;);</span><br><span class="line">for (String s : ts1) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果</span><br><span class="line"></span><br><span class="line">    第一个</span><br><span class="line">第三个</span><br><span class="line">第二个</span><br><span class="line">----------------------------</span><br><span class="line">张三---12</span><br><span class="line">赵六---12</span><br><span class="line">张三---19</span><br><span class="line">王五---20</span><br><span class="line">李四---50</span><br><span class="line">----------------------------</span><br><span class="line">四眼---12</span><br><span class="line">张三---12</span><br><span class="line">张三---19</span><br><span class="line">王五---20</span><br><span class="line">李四---50</span><br><span class="line">----------------------------</span><br><span class="line">第一个</span><br><span class="line">第三个</span><br><span class="line">第二个</span><br><span class="line">第四个</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="collection-e-简单总结">Collection&lt; E &gt;简单总结</h2><dl><dt>Collection&lt; E &gt;</dt><dd>单列集合类型，只能存储引用类型数据，为接口，具体使用需要用实现子类。<br>下面介绍的按其继承关系排列。</dd></dl><ul><li>List&lt; E &gt;：元素有序，可重复<ul><li>ArrayList&lt; E &gt;：增删慢，查找快；底层使用数组，线程不安全，效率高</li><li>Vector&lt; E &gt;：增删满，查找快；底层使用数组，线程安全，效率低</li><li>LinkedList&lt; E &gt;：增删快，查找慢；底层使用链表</li></ul></li><li>Set&lt; E &gt;：元素无序，不重复<ul><li>HashSet&lt; E &gt;：集合元素有序，底层使用哈希表，依靠hashCode()和equals()方法，保证元素唯<ul><li>LinkedHashSet&lt; E &gt;：底层是链表和哈希表(链表保证有序，哈希表保证唯一)</li></ul></li><li>TreeSet&lt; E &gt;：底层使用自平衡二叉树，有两种排序方案：自然排序(Comparable)、比较器排序(Comparator)，保证唯一依赖的是排序方法的返回值，0表示元素重复。</li></ul></li></ul><h2 id="map-k-v">Map&lt;K,V &gt;</h2><dl><dt>简述</dt><dd>类型：interface；继承：Object<br>该集合是一种将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。Map的数据结构与键有关，是双列结构。<br>该接口的常用实现子类：HashMap&lt;K,V&gt;、LinkHashMap&lt;K,V&gt;和TreeMap&lt;K,V&gt;。</dd><dt>方法介绍</dt><dd>接口仅对方法进行定义。</dd></dl><ul><li>添加功能</li></ul><blockquote><p>V put(K key,V value) —— 添加/修改键值对元素，键如果存在则将旧值替换，不存在则直接添加元素。<br>void putAll(Map&lt;? extends K&gt;,&lt;? extends V&gt; m) —— 将源集合添加至目标集合。</p></blockquote><ul><li>删除功能</li></ul><blockquote><p>void clear() —— 清除目标集合中的所有键值对元素。<br>V remove(Object key) —— 移除指定键对应的元素，返回被移除的值，不存在返回null。</p></blockquote><ul><li>判断功能</li></ul><blockquote><p>boolean containsKey(Object key) —— 判断该键在目标集合中是否存在。<br>boolean containsValue(Object value) —— 判断指定的值在目标集合中是否存在。<br>boolean isEmpty() —— 判断该集合是否为空。</p></blockquote><ul><li>获取功能</li></ul><blockquote><p>V get(Object key) —— 得到指定键映射的值。<br>Collection<v> values() —— 返回此映射中包含的值的 Collection 视图<br>Set<k> keySet() —— 返回此映射中包含的键的 Set 集合视图<br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() —— 返回此映射中包含映射关系的 Set 集合视图。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></k></v></p></blockquote><ul><li>长度功能</li></ul><blockquote><p>int size() —— 得到集合元素的大小。</p></blockquote><dl><dt>代码演示</dt><dd>Map&lt;K,V&gt;是一种双列集合，并且其中键是唯一的。</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">//创建Map集合,接口不能创建对象</span><br><span class="line">Map&lt;String,String&gt; m = new HashMap&lt;&gt;();</span><br><span class="line">//添加元素，如果集合中元素键已存在，新的元素值将会替换</span><br><span class="line">m.put(&quot;火警&quot;,&quot;119&quot;);</span><br><span class="line">m.put(&quot;急救&quot;,&quot;120&quot;);</span><br><span class="line">m.put(&quot;匪警&quot;,&quot;110&quot;);</span><br><span class="line">m.put(&quot;火警&quot;,&quot;未知&quot;);</span><br><span class="line">m.put(null, null);</span><br><span class="line">//清除集合元素</span><br><span class="line">//m.clear();</span><br><span class="line">m.remove(&quot;火警&quot;);</span><br><span class="line">//判断指定键是否存在集合中</span><br><span class="line">System.out.println(&quot;判断急救在集合中：&quot; + m.containsKey(&quot;急救&quot;));</span><br><span class="line">System.out.println(&quot;判断120在集合中：&quot; + m.containsValue(&quot;120&quot;));</span><br><span class="line">System.out.println(&quot;判断集合是否为空：&quot; + m.isEmpty());</span><br><span class="line">System.out.println(&quot;得到集合的键值对数量：&quot; + m.size());</span><br><span class="line">//得到指定键的值</span><br><span class="line">System.out.println(&quot;获取键为匪警的值：&quot; + m.get(&quot;匪警&quot;));</span><br><span class="line">//得到集合的所有键</span><br><span class="line">Set&lt;String&gt; s = m.keySet();</span><br><span class="line">for(String ss : s)&#123;</span><br><span class="line">System.out.println(ss + &quot;、&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//得到集合的所有值</span><br><span class="line">Collection&lt;String&gt; c = m.values();</span><br><span class="line">for(String a : c)&#123;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">//获取集合的键值对</span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; set = m.entrySet();</span><br><span class="line">for(Map.Entry&lt;String,String&gt; me : set)&#123;</span><br><span class="line">System.out.println(me.getKey() + &quot;---&quot; + me.getValue());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果</span><br><span class="line"></span><br><span class="line">    判断急救在集合中：true</span><br><span class="line">判断120在集合中：true</span><br><span class="line">判断集合是否为空：false</span><br><span class="line">得到集合的键值对数量：3</span><br><span class="line">获取键为匪警的值：110</span><br><span class="line">急救、</span><br><span class="line">null、</span><br><span class="line">匪警、</span><br><span class="line">120</span><br><span class="line">null</span><br><span class="line">110</span><br><span class="line">急救---120</span><br><span class="line">null---null</span><br><span class="line">匪警---110</span><br><span class="line">&#123;急救=120, null=null, 匪警=110&#125;</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="hashmap-k-v">HashMap&lt;K,V&gt;</h2><dl><dt>简述</dt><dd>类型：实体类；继承：AbstractMap&lt;K,V&gt;<br>实现：Map&lt;K,V&gt;, Cloneable, Serializable<br>AbstractMap&lt;K,V&gt;：类型：Abstract；实现：Map&lt;K,V&gt;<br>基于哈希表的 Map&lt;K,V&gt; 接口的实现。此实现允许使用 null 值和 null 键；但不保证集合的顺序，特别是它不保证该顺序恒久不变。</dd><dt>方法介绍</dt><dd>没有新增方法，均为继承与实现方法的重写。</dd><dt>代码演示</dt><dd>略…</dd></dl><h2 id="linkedhashmap-k-v">LinkedHashMap&lt;K,V&gt;</h2><dl><dt>简述</dt><dd>类型：实现类；继承：HashMap&lt;K,V&gt;<br>实现： Map&lt;K,V&gt;<br>LinkHashMap&lt;K,V&gt;是通过<strong>哈希表和链表</strong>实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链表定义了集合迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。</dd><dt>方法介绍</dt><dd>没有新增方法，均为继承与实现方法的重写。</dd><dt>代码演示</dt><dd>略…</dd></dl><h2 id="treemap-k-v">TreeMap&lt;K,V&gt;</h2><dl><dt>简述</dt><dd>基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。如果是存储自定义对象，这是就要在元素所属的类中实现自然排序接口，或者使用有参的构造方法实现比较器排序</dd><dt>方法介绍</dt><dd>很多的新增方法，但是一般不常用，需要了解，查看<a href="http://www.runoob.com/java/java-collections.html" title="菜鸟教程" target="_blank" rel="noopener">JAVA API</a></dd><dt>代码演示</dt><dd>TreeMap&lt;K,V&gt;是基于二叉树的数据结构存储元素集合。</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void treeMaps()&#123;</span><br><span class="line">TreeMap&lt;Student,Integer&gt; ts = new TreeMap&lt;&gt;();</span><br><span class="line">ts.put(new Student(&quot;张三&quot;,15),101);</span><br><span class="line">ts.put(new Student(&quot;李四&quot;,10),102);</span><br><span class="line">ts.put(new Student(&quot;王五&quot;,46),103);</span><br><span class="line">ts.put(new Student(&quot;张三&quot;,45),104);</span><br><span class="line">ts.put(new Student(&quot;赵六&quot;,85),105);</span><br><span class="line">Set&lt;Map.Entry&lt;Student,Integer&gt;&gt; s = ts.entrySet();</span><br><span class="line">for(Map.Entry&lt;Student,Integer&gt; m : s)&#123;</span><br><span class="line">Student st = m.getKey();</span><br><span class="line">System.out.println(st.getName()+ &quot;---&quot; + st.getAge()+ &quot;---&quot;+ m.getValue());</span><br><span class="line">&#125;</span><br><span class="line">//通过键获取一个键-值映射关系</span><br><span class="line">Map.Entry&lt;Student,Integer&gt; en = ts.ceilingEntry(new Student(&quot;张三&quot;,15));</span><br><span class="line">System.out.println(en.getKey().getName()+en.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*输出结果</span><br><span class="line"></span><br><span class="line">李四---10---102</span><br><span class="line">张三---15---101</span><br><span class="line">张三---45---104</span><br><span class="line">王五---46---103</span><br><span class="line">赵六---85---105</span><br><span class="line">张三101</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="map-k-v-简单总结">Map&lt;K,V&gt;简单总结</h2><dl><dt>Map&lt;K,V&gt;</dt><dd>这是双列集合，采用键值对的方式，数据结构与键有关，与值无关。</dd></dl><ul><li>HashMap&lt;K,V&gt;：采用哈希表保证元素的唯一性，但是集合元素不保证有序，必须实现hashCode()和equals()。-LinkedHashMap&lt;K,V&gt;：采用链表加哈希表的数据结构，用链表保证有序，哈希表保证元素唯一。</li><li>TreeMap&lt;K,V&gt;：采用红黑树数据结构保证元素的唯一性；该种集合，元素对象所属类需要实现Comparable<t>接口或集合构造方法参数是一个比较器排序的对象Comparator<t>。</t></t></li></ul><hr><h2 id="collections集合工具">Collections集合工具</h2><dl><dt>简述</dt><dd>类名：Collections；<br>作用：此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。<br>方法：<strong>Collections</strong>该类提供了静态方法。</dd><dt>方法介绍</dt><dd>集合对象直接使用静态方法。</dd></dl><blockquote><p>void sort(List<t> list) —— 默认情况是自然排序，集合元素所属的类必须实现自然排序接口才可以使用此方法。<br>int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) —— 使用二分搜索法搜索指定列表，以获得指定对象。<br>void swap(List&lt;?&gt; list, int i, int j) —— 在指定列表的指定位置处交换元素。<br>Collection<t> synchronizedCollection(Collection<t> c) —— 返回指定 collection 支持的同步（线程安全的）collection。<br>还有其他获取同步类型的集合…<br>boolean replaceAll(List<t> list, T oldVal, T newVal) —— 使用另一个值替换列表中出现的所有某一指定值。<br><t> max(Collecton&lt;&lt;? extends T&gt; coll) —— 根据元素的自然顺序，返回给定 collection 的最大元素。<br>void reverse(List&lt;?&gt; list) —— 反转指定列表中元素的顺序。<br>void shuffle(List&lt;?&gt; list) —— 使用默认随机源对指定列表进行置换。</t></t></t></t></t></p></blockquote><p><strong>还有更多的方法可以方便的对集合对象操作</strong></p><dl><dt>小结</dt><dd>Collections工具类可以方便的对集合元素操作。<br>例如：元素的替换、集合的排序、元素的查找等</dd></dl><hr><h3 id="更多-java-集合-方法学习参考-java-api">更多 Java__集合 方法学习参考 <a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">JAVA API</a></h3><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Iterator对象：<br>方法：boolean hasNext()，E next()，void remove()。<br>hasNext()：如果迭代后面仍有元素，返回true。<br>next()：返回迭代的下一个元素，并同时指向下一个元素。<br>remove()：从集合中移除迭代器返的最后一个元素,每调用一次next仅可以用一次该方法。<br>Iterator接口方法是在实现类中通过内部类实现，以此来针对不同的数据组织形式，编写hasNext(),next()和remove()方法。<br>迭代器是依赖于集合存在的，如果在使用迭代器的时候，使用集合方法修改元素，这时迭代器并不能发现集合元素的变化，所以就会报错：<br>【ConcurrentModificationException：当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。】<br>A: 有时就是需要在遍历时添加元素，这时就需要解决这种异常错误，有两种方法；<br>在使用迭代器遍历时，用迭代器提供的方法修改元素，但是在Iterator中并没有提供添加元素的方法，这就需要用到ListIterator接口提供的方法（注意：只有在List集合中存在该接口）。<br>B: 使用集合遍历元素，利用集合提供的方法修改元素（普通for循环方式）。<br><em>不允许既使用迭代器又使用集合。</em> <a href="#fnref1" class="footnote-backref">↩</a> <a href="#fnref1:1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Map.Entry&lt;K,V&gt;：这是一种键值对实体对象，提供了获取键和值的方法：getKey()、getValue()，在对集合进行键值对遍历时可以使用这种方法，也可以使用键找值的方法遍历。 <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      <categories>
          
          <category> 以梦为马 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
            <tag> Collection </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HEXO+github+git搭建博客及MD语法</title>
      <link href="/2018/03/28/github_HEXO/"/>
      <url>/2018/03/28/github_HEXO/</url>
      <content type="html"><![CDATA[<p>欢迎使用 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> ，这里有更多的 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a> 信息。在使用Hexo时遇到任何问题， 寻找问题答案可以到 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">这里</a> 或者向他咨询 <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>。</p><h1>HEXO使用的基本方法</h1><h2 id="创建一篇文章">创建一篇文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post Name"</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h2 id="本地运行服务器">本地运行服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h2 id="本地运行服务器同时为调试模式">本地运行服务器同时为调试模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server --debug</span><br></pre></td></tr></table></figure><h2 id="生成静态文件">生成静态文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="部署到远程站点">部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h2 id="文章语法-标题-水平线-商标-引用-列表">文章语法（标题，水平线，商标，引用，列表）</h2><dl><dt>标题的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1 Heading</span><br><span class="line">## h2 Heading</span><br><span class="line">### h3 Heading</span><br><span class="line">#### h4 Heading</span><br><span class="line">##### h5 Heading</span><br><span class="line">###### h6 Heading</span><br></pre></td></tr></table></figure><p>由于标题一和标题二会产生目录，故不演示效果。</p><h3 id="h3-heading">h3 Heading</h3><h4 id="h4-heading">h4 Heading</h4><h5 id="h5-heading">h5 Heading</h5><h6 id="h6-heading">h6 Heading</h6></dd><dt>水平线的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***  水平线</span><br><span class="line">---  水平线</span><br><span class="line">___  水平线</span><br></pre></td></tr></table></figure><hr><hr><hr></dd><dt>商标符号的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(c) (C) (r) (R) (tm) (TM) (p) (P) +-</span><br><span class="line">?????? !!!! -- --- ,,</span><br></pre></td></tr></table></figure><p>© © ® ® ™ ™ § § ±<br>??? !!! – — ,</p></dd><dt>引用文字的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用一</span><br><span class="line">&gt;&gt; 引用二</span><br><span class="line">&gt;&gt;&gt; 引用三</span><br></pre></td></tr></table></figure><blockquote><p>引用一</p><blockquote><p>引用二</p><blockquote><p>引用三</p></blockquote></blockquote></blockquote></dd><dt>列表的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 列表1</span><br><span class="line">2. 列表2</span><br><span class="line">1. 子列表1</span><br><span class="line">2. 子列表2</span><br><span class="line">1. 孙列表1</span><br><span class="line">3. 列表3</span><br><span class="line"></span><br><span class="line">+ 无序列表</span><br><span class="line">+ 子无序列表</span><br><span class="line">+ 孙无序列表</span><br><span class="line">+ 无序列表</span><br></pre></td></tr></table></figure><ol><li>列表1</li><li>列表2<ol><li>子列表1</li><li>子列表2<ol><li>孙列表1</li></ol></li></ol></li><li>列表3</li></ol><ul><li>无序列表<ul><li>子无序列表<ul><li>孙无序列表</li></ul></li></ul></li><li>无序列表</li></ul></dd></dl><h2 id="文章语法-代码段-表格-链接-标记-自定列表">文章语法（代码段，表格，链接，标记，自定列表）</h2><dl><dt>代码段的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文字段中的代码：`System.out.println(&quot;Hello World&quot;);`     </span><br><span class="line">代码段使用</span><br><span class="line">``` </span><br><span class="line">public void main(String[] arge)&#123;</span><br><span class="line">System.out.println(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">每行的空格数为4个以后：后面的文字自动转化为代码形式</span><br></pre></td></tr></table></figure><p>文字段中的代码：<code>System.out.println(&quot;Hello World&quot;);</code><br>代码段使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void main(String[] arge)&#123;</span><br><span class="line">System.out.println(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每行的空格数为4个以后：后面的文字自动转化为代码形式</p></dd><dt>表格的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表 —— 头 —— 1 | 表 —— 头 —— 2 | 表 —— 头 —— 3 |</span><br><span class="line">| :---- | :----: | ----: |</span><br><span class="line">| 居左 | 居中 | 居右 |</span><br><span class="line">| 内容 | 内容 | 内容 |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">表 —— 头 —— 1</th><th style="text-align:center">表 —— 头 —— 2</th><th style="text-align:right">表 —— 头 —— 3</th></tr></thead><tbody><tr><td style="text-align:left">居左</td><td style="text-align:center">居中</td><td style="text-align:right">居右</td></tr><tr><td style="text-align:left">内容</td><td style="text-align:center">内容</td><td style="text-align:right">内容</td></tr></tbody></table></dd><dt>链接的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[文字链接](http://blog.itlzb.cn &quot;耳语心声&quot;)</span><br><span class="line">![图标，图片链接](http://blog.itlzb.cn/images/icon.jpg)</span><br><span class="line">Autoconverted link https://github.com/nodeca/pica (enabled linkify)</span><br></pre></td></tr></table></figure><p><a href="http://blog.itlzb.cn" title="耳语心声" target="_blank" rel="noopener">文字链接</a></p><p><img src="https://octodex.github.com/images/dojocat.jpg" alt="图标，图片链接"></p><p>Autoconverted link <a href="https://github.com/nodeca/pica" target="_blank" rel="noopener">https://github.com/nodeca/pica</a> (enabled linkify)</p></dd><dt>标记文字的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Footnote 1 link[^first].</span><br><span class="line">Footnote 2 link[^second].</span><br><span class="line">Inline footnote^[Text of inline footnote] definition.</span><br><span class="line">Duplicated footnote reference[^second].</span><br><span class="line">[^first]: Footnote **can have markup**</span><br><span class="line">    and multiple paragraphs.</span><br><span class="line">[^second]: Footnote text.</span><br></pre></td></tr></table></figure><p>Footnote 1 link<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p><p>Footnote 2 link<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><p>Inline footnote<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> definition.</p><p>Duplicated footnote reference<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2]</a></sup>.</p></dd><dt>定义列表的使用</dt><dd><p>代码及效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义列表类型一的使用</span><br><span class="line">:   代码及效果</span><br><span class="line"></span><br><span class="line">文字内容</span><br><span class="line"></span><br><span class="line">定义列表类型二的使用</span><br><span class="line">  ~ 代码及效果</span><br><span class="line"></span><br><span class="line">文字内容</span><br></pre></td></tr></table></figure><dl><dt>定义列表类型一的使用</dt><dd>代码及效果</dd></dl><p>文字内容</p><dl><dt>定义列表类型二的使用</dt><dd>代码及效果</dd></dl><p>文字内容</p><p>这是定义的标记文字的链接位置</p></dd></dl><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Footnote <strong>can have markup</strong>and multiple paragraphs. <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Footnote text. <a href="#fnref2" class="footnote-backref">↩</a> <a href="#fnref2:1" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>Text of inline footnote <a href="#fnref3" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      <categories>
          
          <category> 闲杂随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> github </tag>
            
            <tag> Coding </tag>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
