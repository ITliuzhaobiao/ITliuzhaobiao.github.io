<!DOCTYPE html>
<html lang="en">




<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - 耳语心声</title>
  

  
  
  <meta name="description" content="个人博客">
  <meta name="author" content="Mr.Liu">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>


<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script
src="https://code.jquery.com/jquery-3.3.1.min.js"
integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


 

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/icon.png' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">耳语心声</a>
			</h1>
			<subtitle>
				人生若只如初见，何事悲风秋画扇
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
		
			
		
		
			<div class='nav-item'>
				
					<div class="nav-name">
				
					<a class='nav-link' href="/CV/index.html">
						<span>C V </span>
					</a>
				</div>
			</div>
		
	
		
			
		
		
			<div class='nav-item'>
				
					<div class="nav-name">
				
					<a class='nav-link' href="/categories/以梦为马/">
						<span>以梦为马 </span>
					</a>
				</div>
			</div>
		
	
		
			
		
		
			<div class='nav-item'>
				
					<div class="nav-name">
				
					<a class='nav-link' href="/categories/简生活/">
						<span>简生活 </span>
					</a>
				</div>
			</div>
		
	
		
			
		
		
			<div class='nav-item'>
				
					<div class="nav-name">
				
					<a class='nav-link' href="/categories/闲杂随笔/">
						<span>闲杂随笔 </span>
					</a>
				</div>
			</div>
		
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/colorful-outlined/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/colorful-outlined/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/colorful-outlined/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
			
			
				
			
				
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/CV/index.html">
							<span>C v</span>
						</a>
					</div>
			</div>
		
		
			
			
				
			
				
					
				
			
		
		
			
			
				
			
				
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/categories/简生活/">
							<span>简生活</span>
						</a>
					</div>
			</div>
		
		
			
			
				
					
				
			
				
			
		
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/闲杂随笔/">
						<span>闲杂随笔</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/以梦为马/">
						<span>以梦为马</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class='search-container'>
	<input type="text" id='search-form' placeholder="请输入要查找的文章信息">

	<ul class="cat-list">
		
			<li><a href="/categories/闲杂随笔/"><img src="/images/闲杂随笔.svg" alt="闲杂随笔" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='闲杂随笔'></a></li>
		
			<li><a href="/categories/以梦为马/"><img src="/images/以梦为马.svg" alt="以梦为马" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='以梦为马'></a></li>
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"HEXO+github+git搭建博客及MD语法","date":"2018-03-28T14:21:24.709Z","content":"欢迎使用 Hexo ，这里有更多的 文档 信息。在使用Hexo时遇到任何问题， 寻找问题答案可以到 这里 或者向他咨询 GitHub。\nHEXO使用的基本方法\n创建一篇文章\n1$ hexo new My New Post Name\n更多信息: Writing\n本地运行服务器\n1$ hexo server\n更多信息: Server\n本地运行服务器同时为调试模式\n1$ hexo server --debug\n生成静态文件\n1$ hexo generate\n更多信息: Generating\n部署到远程站点\n1$ hexo deploy\n更多信息: Deployment\n文章语法（标题，水平线，商标，引用，列表）\n\n标题的使用\n\n代码及效果\n123456# h1 Heading## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading\n由于标题一和标题二会产生目录，故不演示效果。\nh3 Heading\nh4 Heading\nh5 Heading\nh6 Heading\n\n水平线的使用\n\n代码及效果\n123***  水平线---  水平线___  水平线\n\n\n\n\n商标符号的使用\n\n代码及效果\n12(c) (C) (r) (R) (tm) (TM) (p) (P) +-?????? !!!! -- --- ,,\n© © ® ® ™ ™ § § ±\n??? !!! – — ,\n\n引用文字的使用\n\n代码及效果\n123&gt; 引用一&gt;&gt; 引用二&gt;&gt;&gt; 引用三\n\n引用一\n\n引用二\n\n引用三\n\n\n\n\n列表的使用\n\n代码及效果\n12345678910111. 列表12. 列表2\t1. 子列表1\t2. 子列表2\t\t1. 孙列表13. 列表3+ 无序列表\t+ 子无序列表\t\t+ 孙无序列表+ 无序列表\n\n列表1\n列表2\n\n子列表1\n子列表2\n\n孙列表1\n\n\n\n\n列表3\n\n\n无序列表\n\n子无序列表\n\n孙无序列表\n\n\n\n\n无序列表\n\n\n\n文章语法（代码段，表格，链接，标记，自定列表）\n\n代码段的使用\n\n代码及效果\n12345678文字段中的代码：`System.out.println(&quot;Hello World&quot;);`     代码段使用``` public void main(String[] arge)&#123;\tSystem.out.println(&quot;Hello World&quot;);&#125;```  每行的空格数为4个以后：后面的文字自动转化为代码形式\n文字段中的代码：System.out.println(&quot;Hello World&quot;);\n代码段使用\n123public void main(String[] arge)&#123;\t\tSystem.out.println(&quot;Hello World&quot;);&#125;\n每行的空格数为4个以后：后面的文字自动转化为代码形式\n\n表格的使用\n\n代码及效果\n1234| 表 —— 头 —— 1 | 表 —— 头 —— 2 | 表 —— 头 —— 3 || :---- | :----: | ----: || 居左 | 居中 | 居右 || 内容 | 内容 | 内容 |\n\n\n\n表 —— 头 —— 1\n表 —— 头 —— 2\n表 —— 头 —— 3\n\n\n\n\n居左\n居中\n居右\n\n\n内容\n内容\n内容\n\n\n\n\n链接的使用\n\n代码及效果\n123[文字链接](http:blog.itlzb.cn &quot;耳语心声&quot;)![图标，图片链接](http:blog.itlzb.cnimagesicon.jpg)Autoconverted link https:github.comnodecapica (enabled linkify)\n文字链接\n\nAutoconverted link https:github.comnodecapica (enabled linkify)\n\n标记文字的使用\n\n代码及效果\n1234567Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup**    and multiple paragraphs.[^second]: Footnote text.\nFootnote 1 link[1].\nFootnote 2 link[2].\nInline footnote[3] definition.\nDuplicated footnote reference[2].\n\n定义列表的使用\n\n代码及效果\n123456789定义列表类型一的使用:   代码及效果文字内容定义列表类型二的使用  ~ 代码及效果文字内容\n\n定义列表类型一的使用\n代码及效果\n\n文字内容\n\n定义列表类型二的使用\n代码及效果\n\n文字内容\n这是定义的标记文字的链接位置\n\n\n\n\n\nFootnote can have markup\nand multiple paragraphs. ↩\n\nFootnote text. ↩ ↩\n\nText of inline footnote ↩\n\n\n\n","tags":["HEXO","github","Coding","搭建博客"],"path":"2018/03/28/github_HEXO/","external_link":""},{"title":"JAVA+集合","date":"2018-06-16T14:46:08.000Z","content":"JAVA集合框架主要包括两种类型的容器，一种是单列集合（Collection），存储一个元素集合；另一种是双列集合（Map），存储键值对映射。JAVA集合可以更方便的存储数据，相对于数组来说有很大的优势，集合的容量可以动态的添加，而使用数组定义后大小不可变。\n总述：集合三大接口Iterator、Collection和Map；均属于java.util包下\n\n集合与数组的区别\n\n  \n\n\n\n\n数组在定义后，其长度是固定的，但如果需要增大数组，需要自己编写动态数组的方法；可以存储基本类型数据，也可以存储引用类型数据。\n\n\n集合的长度是可动态变化的，只能存储引用类型数据。（基本类型可以使用封装类）\n\n\n\n\nCollection&lt; E &gt;\n\n简述\n类型：interface; 继承：Iterable&lt; E &gt;\n该接口在JDK1.2之后出现；不提供任何方法的具体实现，对象实例表示可以存储一组对象，这一组对象称为Collection的元素；其提供了单列集合共有的方法定义，Collection的具体子类有允许元素重复及不允许元素重复定义，同时Collection的具体子类有元素有序和无序之分。\nCollection包括两个常用子接口：List&lt; E &gt;和Set&lt; E &gt;。\n方法介绍\n访问修饰符：默认（public abstract）；参数为源集合，调用者为目标集合。\n\n\n添加方法\n\n\nboolean add(Object o) —— 添加Object类型数据，返回添加结果。\nboolean addAll(Collection&lt;? extends E&gt; c) —— 将源集合中所有元素添加至目标集合，返回添加结果。\n\n\n删除方法\n\n\nvoid clear() —— 移除集合中全部元素,无返回值。\nboolean remove(Object o) —— 移除目标集合中指定元素，返回操作结果。\nboolean removeAll(Collection&lt;?&gt; c) —— 移除目标集合中源集合中存在的相同元素，目标集合发生更改，返回操作结果（集合改变，返回true）。\n\n\n判断方法\n\n\nboolean contains(Object o) —— 判断指定元素是否存在目标集合，返回查找结果。\nboolean containsAll(Collection&lt;&gt; c) —— 判断目标集合中是否包含源集合全部元素，返回查找结果。\nboolean isEmpty() —— 判断目标集合是否为空，返回判断结果。\n\n\n获取方法\n\n\nint size() —— 得到集合的长度，返回查询的长度值。\nIterator Iterator() —— 集合的迭代器，用于集合的遍历，返回目标集合用于遍历的iterator对象。[1]\nObject[] toArray() —— 将目标集合所有元素转换为数组形式，返回Object类型数组\n\n\n交集方法\n\n\nboolean retainAll(Collection c)————仅保留两个集合中重复的元素至目标集合中，目标集合发生改变，返回true。\n\n\n代码演示\nCollection接口方法的使用(因为是接口，实例化必须使用其实现子类。)\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void main(String[] args)&#123;\t创建集合对象，接口不能实例化，需要使用其子实现类实例化\tCollection&lt;Student&gt; coll = new ArrayList&lt;&gt;();\tCollection&lt;Student&gt; c = new ArrayList&lt;&gt;();\t创建要添加的元素\tStudent s1 = new Student(&quot;张三&quot;,12);\tStudent s2 = new Student(&quot;李四&quot;,15);\tStudent s3 = new Student(&quot;王五&quot;,19);\t向集合中添加元素\tcoll.add(s1);\tcoll.add(s2);\tcoll.add(s3);\tc.add(s1);\tc.add(s2);\t向集合中添加一个集合\tcoll.addAll(c);\t移除集合中指定的单个实例\tcoll.remove(s1);\t移除集合中与参数集合中所有相同的元素\tcoll.removeAll(c);\t移除集合中所有的元素\tc.clear();\tc.add(s3);\tSystem.out.println(&quot;判断元素s1是否存在集合coll中：&quot; + coll.contains(s1));\tSystem.out.println(&quot;判断参数集合中元素是否为调用集合元素的子集：&quot; + coll.containsAll(c));\tSystem.out.println(&quot;判断集合是否为空：&quot; + coll.isEmpty());\t将集合对象转为一个数组\tObject[] o = coll.toArray();\tStudent s = (Student)o[0];\tSystem.out.println(s.getName()+ &quot;---&quot; + s.getAge());\t获取集合的大小\tSystem.out.println(&quot;该集合共有元素：&quot; + coll.size());\t保留两个集合的交集元素,保留元素存放在调用集合中\tcoll.retainAll(c);\t使用Iterator方法遍历集合\tIterator&lt;Student&gt; i = c.iterator();\twhile(i.hasNext())&#123;\t\tStudent ss = new Student();\t\tss = i.next();\t\tSystem.out.println(ss.getName() + &quot;---&quot; + ss.getAge());\t&#125;&#125;*输出结果(需要一个Student实体类)：\t判断元素s1是否存在集合coll中：false\t判断参数集合中元素是否为调用集合元素的子集：true\t判断集合是否为空：false\t王五---19\t该集合共有元素：1\t王五---19*\n以上是对单列集合接口的介绍，同时它为其单列集合的父类，定义的方法，在之后子类中均需要实现。那么接下来就介绍其常用子接口与子类。\n\nList&lt; E &gt;\n\n简述\n类型：interface；继承：Collection&lt; E &gt;\n该类型集合元素可以重复，有序；用户可以对元素的插入位置精确的控制，也可以通过整数索引访问元素。\n常用实现子类：ArrayList&lt; E &gt;、LinkedList&lt; E &gt;和Vector&lt; E &gt;。\nList 接口提供了特殊的迭代器，称为 ListIterator，除了允许 Iterator 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器。（这就是上面所说的Iterator迭代器）[1]\n方法介绍\n这里只介绍新增及改进的方法定义。\n\n\n添加方法\n\n\nvoid add(int index,E e) —— 向目标集合指定位置添加指定元素，无返回值。\nboolean addAll(Collection&lt;? extends E&gt; c) —— 添加源集合中的所有元素到目标集合的尾部，目标集合改变返回true。\nboolean addAll(int index,Collection&lt;? extends E&gt; c) —— 向目标集合指定位置添加源集合的所有元素。\n【注意：在向指定位置添加元素时，针对使用索引的方法，切记索引值要在集合已存在的索引范围【0 — m+1】，如果超过范围，则会运行错误。（IndexOutOfBoundExpeception）】。\n\n\n获取方法\n\n\nE get(int index) —— 获取集合指定位置元素，返回获取的元素。\nint indexOf(Object o) —— 获取指定元素的第一次出现索引值，不存在返回-1。\nint lastIndexOf(Object o) —— 获取指定元素最后出现的索引值，不存在返回-1。\nList subList(int fromIndex,int toIndex) —— 获取目标集合中的子集元素，返回指定范围内的集合元素。\nListIterator listIterator() —— 获取此集合列表元素的列表迭代器（按适当顺序）。\nListIterator listIterator(int index) —— 获取列表指定位置开始元素的列表迭代器（按适当顺序）。\n\n\n移除方法\n\n\nE remove(int index) —— 移除目标集合中指定索引处元素，返回被移除元素。\nE set(int index,E e) —— 替换目标集合中指定位置元素，返回被替换元素。\n\n\n代码演示\nList&lt; E &gt;也为接口类型，新增了一些方法。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args)&#123;\t创建List实例\tList&lt;Integer&gt; listOne = new ArrayList&lt;&gt;();\tList&lt;Integer&gt; listTwo = new ArrayList&lt;&gt;();\t向集合中添加元素\tlistOne.add(1);\tlistOne.add(3);\t向集合指定位置添加元素\tlistOne.add(1,2);\tlistTwo.add(4);\t向集合指定位置添加另一集合的全部元素\tlistOne.addAll(0,listTwo);\tlistOne.add(4);\tSystem.out.println(&quot;获取到指定索引的元素：&quot; + listOne.get(2));\tSystem.out.println(&quot;获取指定元素第一次出现的索引值：&quot; + listOne.indexOf(4));\tSystem.out.println(&quot;获取指定元素最后一次出现的索引值：&quot; + listOne.lastIndexOf(4));\tSystem.out.println(&quot;移除指定索引处的元素：&quot; + listOne.remove(0));\tSystem.out.println(&quot;替换指定索引处的元素：&quot; + listOne.set(0,4));\t获取集合指定范围的集合元素\tList&lt;Integer&gt; ll = listOne.subList(1,3);\tSystem.out.println(ll);\tSystem.out.println(listOne);\tList类型集合特有的遍历方法（普通for循环）\tfor(int i = 0;i &lt; listOne.size();i++)&#123;\t\tSystem.out.print(listOne.get(i) + &quot;、&quot;);\t&#125;\tSystem.out.println();\tListIterator的父亲是Iterator,同样也是通过内部类实现该接口中的方法\tListIterator&lt;Integer&gt; li = listOne.listIterator();\t集合元素向后输出\twhile(li.hasNext())&#123;\t\tSystem.out.print(li.next() + &quot;、&quot;);\t&#125;\tSystem.out.println();\t集合元素向前输出\twhile(li.hasPrevious())&#123;\t\tSystem.out.print(li.previous() + &quot;、&quot;);\t&#125;&#125;*输出结果：\t获取到指定索引的元素：2\t获取指定元素第一次出现的索引值：0\t获取指定元素最后一次出现的索引值：4\t移除指定索引处的元素：4\t替换指定索引处的元素：1\t[2, 3]\t[4, 2, 3, 4]\t4、2、3、4、\t4、2、3、4、\t4、3、2、4、*\n该集合类型允许元素重复，同时保证数据元素是有序的，元素可以为null。\nArrayList&lt; E &gt;\n\n简述\n类型：实体类；继承：AbstractList&lt; E &gt;\nAbstractList&lt; E &gt;：类型：抽象类；继承：AbstractCollection&lt; E &gt;；实现：List&lt; E &gt;\nAbstractList&lt; E &gt;抽象类实现了部分List&lt; E &gt;接口的方法。\n该类型集合插入、删除操作慢，查找快，线程不安全，效率高；内部是使用动态数组实现，初始容量大小为10，集合容量可以动态扩充，通过方法：Arrays.copyOf(oldArray,newArrayLength)实现的扩充方法。\n方法介绍\n仅介绍新增方法\n\n\n获取方法\n\n\nObject clone() —— 克隆一个与目标集合相同的集合对象，返回克隆的对象。\n\n\n调整方法\n\n\nvoid trimToSize() —— 将目标集合的容量调整为列表的大小，无返回值。\n\n\n代码演示\nArrayList&lt; E &gt;具体实现类，底层通过数组实现的集合。\n\n1234567891011121314151617181920212223242526272829public static void main(String[] args)&#123;\t JDK1.5及之前泛型前后都要写\tArrayList&lt;String&gt; arrayLists = new ArrayList&lt;&gt;();  创建集合实例对象\tarrayLists.add(&quot;your name&quot;);  向集合中添加第一个元素\tarrayLists.add(&quot;your age&quot;);  添加第二个元素\tarrayLists.add(1, &quot;your sex&quot;);  添加第三个元素\tString e = arrayLists.get(2);  得到集合中索引为2的元素\tint index = arrayLists.indexOf(&quot;your age&quot;);  得到指定元素的索引值\tboolean empty = arrayLists.isEmpty();  判断集合元素是否为空\tarrayLists.remove(2);  移除集合中指定索引处的元素\tarrayLists.set(1, &quot;your sweetheart&quot;);  将集合指定索引处的元素替换\tarrayLists.add(2, e);  向指定索引处添加元素\tint size = arrayLists.size();  得到集合的大小\tboolean exist = arrayLists.contains(&quot;your age&quot;);  判断集合中是否存在指定元素\tObject[] p = arrayLists.toArray();  将集合转换为数组 Object类型数组不可以强制转换为String类型数组。\tSystem.out.println(&quot;取出下标为2的元素：&quot; + e + &quot;；取出元素为“your age”的索引值：&quot; + index + &quot;；集合是否为空：&quot; + empty);\tSystem.out.println(&quot;最后该集合的大小为：&quot; + size + &quot;；集合中是否存在元素“your age”：&quot; + exist);\tSystem.out.print(&quot;集合中的数据：&quot;);\t普通for循环遍历集合\tfor (Object o : p) &#123;\t\tSystem.out.print(o.toString() + &quot;,   &quot;);\t&#125;&#125;\t\t*输出结果：\t\t取出下标为2的元素：your age；取出元素为“your age”的索引值：2；集合是否为空：false\t最后该集合的大小为：3；集合中是否存在元素“your age”：true\t集合中的数据：your name,   your sweetheart,   your age,   *\nVector&lt; E &gt;\n\n简述\n类型：实体类；继承：AbstractList&lt; E &gt;；\n实现：List&lt; E &gt;, RandomAccess, Cloneable, java.io.Serializable\n该类型集合插入、删除慢，查找快；线程安全，效率低；内部也是使用动态数组实现。使用比较少，基本使用方法与ArrayList一致；不过因为Vector出现比较早，在1.0版本，而Collection是在1.2中出现，所以Vector又有一些独立的方法。\n方法介绍\nVector集合特有方法\n\n\n添加方法\n\n\nvoid addElement(Object o) —— 添加元素至目标集合中。\n\n\n获取方法\n\nE elementAt(int index) —— 获取目标集合中指定索引处的元素，返回查找元素。\nEnumeration elements() —— 获取目标集合对象中的全部元素，返回全部元素的Enumeration对象。\n\n代码演示\nVector&lt; E &gt;是一种线程安全的，基于数组实现的集合，全部方法均为：synchronized\n\n123456789101112131415161718192021public static void main(String[] args)&#123;\t其添加元素，获取元素的方法在之后的其他集合类型中均进行了改进。\tVector&lt;String&gt; v = new Vector&lt;&gt;();\t使用Vector特有的添加方法添加元素\tv.addElement(&quot;name&quot;);\tv.addElement(&quot;age&quot;);\t获取指定索引处的元素\tSystem.out.println(v.elementAt(0));\t使用特有的方法遍历集合\tEnumeration&lt;String&gt; en =  v.elements();\twhile(en.hasMoreElements())&#123;\t\tSystem.out.println(en.nextElement());\t&#125;&#125;*输出结果：    name    name    age*\nLinkedList&lt; E &gt;\n\n简述\n类型：实体类；继承：AbstractSequentialList&lt; E &gt;；\n实现：List&lt; E &gt;, Deque&lt; E &gt;, Cloneable, java.io.Serializable\n该类型集合插入，删除快，查找慢；内部数据结构是使用双向链表。\n方法介绍\n仅介绍新增特有方法\n(因集合结构是链表类型，故可以更方便的对表头，表尾进行操作。)\n\n\n添加方法\n\n\nvoid addFirst(E e) —— 将元素添加至目标集合的首部，无返回值。\nvoid addLast(E e) —— 将元素添加至目标集合最后一个元素后面（与add方法功能一致）\n\n\n获取方法\n\n\nE getFirst() —— 得到目标集合中的第一个元素，返回获取的元素对象。\nE getLast() —— 得到目标集合中的最后一个元素，并返回。\n\n\n移除方法\n\n\nE removeFirst() —— 移除目标集合中的第一个元素，返回被移除的元素。\nE removeLast() —— 移除目标集合中的最后一个元素，返回被移除的元素。\n\n\n还有一些不常用的方法，详情查看Java API。\n\n\n代码演示：\nLinkList&lt; E &gt;使用的是链表数据结构，对于插入、删除操作非常方便，但是对于查找不方便。\n\n12345678910111213141516171819202122232425262728public static void main(String[] args)&#123;\tLinkedList&lt;String&gt; ll = new LinkedList&lt;&gt;();\t添加元素\tll.addFirst(&quot;第一&quot;);\tll.addFirst(&quot;第二&quot;);\tll.addFirst(&quot;第三&quot;);\tll.addLast(&quot;第四&quot;);\t获取元素\tSystem.out.println(&quot;获取集合的第一个元素：&quot; + ll.getFirst());\tSystem.out.println(&quot;获取集合的最后一个元素：&quot; + ll.getLast());\t移除元素\tSystem.out.println(&quot;移除集合中第一个元素：&quot; + ll.removeFirst());\tSystem.out.println(&quot;移除集合中最后一个元素：&quot; + ll.removeLast());\t遍历集合\tListIterator&lt;String&gt; lit = ll.listIterator();\twhile(lit.hasNext())&#123;\t\tSystem.out.print(lit.next() + &quot;、&quot;);\t&#125;&#125;*输出结果    获取集合的第一个元素：第三    获取集合的最后一个元素：第四    移除集合中第一个元素：第三    移除集合中最后一个元素：第四    第二、第一、*\nSet&lt; E &gt;\n\n简述\n类型：interface；继承：Collection&lt; E &gt;\n集合元素不重复，无序，因基于Map的数据结构，元素存放至key列，故不允许插入null值。\n特性：1、确定性；2、互异性；3、无序性。\n常用实现子类：HashSet&lt; E &gt;和TreeSet&lt; E &gt;。\n方法介绍\n没有新增方法\n代码演示\n略…\n\n下面对其实现子类具体介绍。\nHashSet&lt; E &gt;\n\n简述\n类型：实体类；继承：AbstractSet&lt; E &gt;\n实现：Set, Cloneable, java.io.Serializable\n该集合底层数据结构使用哈希表，通过hashCode()和equals()两个方法保证集合元素的唯一性(从而保证了元素不允许重复。)，所以对于用户自定义的类对象，必须重写hashCode()和equals()[IDE工具可以自动生成]；通过HashMap的put()添加元素，元素存放至其Key中，故元素值不可以为null。\n方法介绍\n该类型集合没有新增方法，其方法均来自父类的实现及重写。\n代码演示\n存储元素时记住为：无序且不重复；元素不能为null。\n\n12345678910111213141516171819202122public static void main(String[] args)&#123; \tStudent对象中需要重写hashCode()和equals()方法，因为添加元素并保证元素的唯一性需要通过这两个方法的返回值决定\tHashSet&lt;Student&gt; hs = new HashSet&lt;&gt;();\ths.add(new Student(&quot;张三&quot;,12));\ths.add(new Student(&quot;李四&quot;,50));\ths.add(new Student(&quot;王五&quot;,20));\ths.add(new Student(&quot;张三&quot;,19));\ths.add(new Student(&quot;张三&quot;,12));\tfor(Student s : hs)&#123;\t\tSystem.out.println(s.getName() + &quot;---&quot; + s.getAge());\t&#125;\t &#125; *输出结果\t（集合元素是无序的，并且重复对象没有添加成功，\t  注：如果没有重写Student的hashCode()和equals()将会出现重复元素）\t 李四---50     张三---12     王五---20     张三---19*\nLinkedHashSet&lt; E &gt;\n\n简述\n类型：实体类；继承：HashSet&lt; E &gt;；\n实现：Set&lt; E &gt;, Cloneable, Serializable\n这种集合保证元素有序且唯一，这种方式的实现是基于哈希表和链表的结合；\n方法介绍 及 代码演示\n没有新增方法，使用与HashSet方法的使用没有差别。\n\nTreeSet&lt; E &gt;\n\n简述\n类型：实体类；继承：AbstractSet&lt; E &gt;\n实现：NavigableSet&lt; E &gt;, Cloneable, java.io.Serializable\n该类型集合底层实现是使用红黑树（自平衡二叉树），具体实现是使用的TreeMap；其集合元素无序（注：元素排列的顺序是按照排序规则进行的排序，排序方式分为：自然排序和比较器排序Comparable，具体排序实现取决于构造方法Comparator）。\n方法介绍\n仅介绍新增方法\n\n\n获取方法\n\n\nIterator&lt; E &gt; descendingIterator() —— 返回在此 set 元素上按降序进行迭代的迭代器。\nNavigableSet&lt; E &gt; descendingSet() —— 返回此 set 中所包含元素的逆序视图。\nE first() —— 返回此 set 中当前第一个（最低）元素。\nE last() —— 返回此 set 中当前最后一个（最高）元素。\nE floor(E e) —— 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。\nE higher(E e) —— 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。\nE lower(E e) —— 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n\n\n移除方法\n\n\nE pollFirst() —— 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。\nE pollLast() —— 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。\n\n\n代码演示\nTreeSet&lt; E &gt;使用时，其元素对象必须存在一种排序规则（自然排序或比较器排序）。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103** 该类集合的唯一性通过定义的排序规则的排序比较方法的返回值决定，返回为0，元素重复* 排序方式有两种：*     自然排序：使元素对象所属的类实现Comparable接口。*     比较器排序：使创建集合时的构造方法的实际参数接受一个Comparator子类对象* 两种排序方法均是在其重写方法中实现排序规则。*public static void main(String[] args)&#123; \t 创建集合对象，使用自然排序，在String类中实现了Comparable&lt;E&gt;接口\tTreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;();\t 添加集合String类型元素\tts.add(&quot;第一个&quot;);\tts.add(&quot;第二个&quot;);\tts.add(&quot;第三个&quot;);\tts.add(&quot;第一个&quot;);  Set集合不允许元素重复\tfor (String s : ts) &#123;\t\tSystem.out.println(s);\t&#125;\tSystem.out.println(&quot;----------------------------&quot;);\t*\t * 存储自定义对象元素需要注意，如果存储自定义对象就必须在自定义对象类中实现Comparable&lt;E&gt;接口。\t * 并实现接口中的compareTo()方法，在方法中定义需要的排序规则。 例：自定义对象有两个属性：年龄和姓名；\t * 设置按照年龄排序，如年龄相同再比较姓名，如果两者均相同则认为同一对象，不重复添加。\t * \t * @Override public int compareTo(Student o) &#123; if(o == null) &#123; return 0; &#125;\t * if(o.getAge() != this.age) &#123; return this.age - o.getAge(); &#125; return\t * this.name.compareTo(o.getName()); &#125;\t *\tTreeSet&lt;Student&gt; ts2 = new TreeSet&lt;&gt;();\tts2.add(new Student(&quot;张三&quot;, 12));\tts2.add(new Student(&quot;李四&quot;, 50));\tts2.add(new Student(&quot;王五&quot;, 20));\tts2.add(new Student(&quot;张三&quot;, 19));\tts2.add(new Student(&quot;赵六&quot;, 12));\tts2.add(new Student(&quot;张三&quot;, 12));\tfor (Student s : ts2) &#123;\t\tSystem.out.println(s.getName() + &quot;---&quot; + s.getAge());\t&#125;\tSystem.out.println(&quot;----------------------------&quot;);\t*\t * 通过有参构造方法，使用比较器比较元素\t * \t * public class MyComparator implements Comparator&lt;Student&gt;&#123;\t * \t\t@Override \t * \t\tpublic int compare(Student o1, Student o2) &#123; \t * \t\t\tif(o1 == null || o2 == null) &#123; return 0; &#125; \t * \t\t\tif(o1.getAge() != o2.getAge()) &#123; return o1.getAge() - o2.getAge(); &#125; \t * \t\t\treturn o1.getName().compareTo(o2.getName()); &#125; \t * \t\t&#125;\t * &#125;\t *\tTreeSet&lt;Student&gt; ts3 = new TreeSet&lt;Student&gt;(new MyComparator());\tts3.add(new Student(&quot;张三&quot;, 12));\tts3.add(new Student(&quot;李四&quot;, 50));\tts3.add(new Student(&quot;王五&quot;, 20));\tts3.add(new Student(&quot;张三&quot;, 19));\tts3.add(new Student(&quot;四眼&quot;, 12));\tts3.add(new Student(&quot;张三&quot;, 12));\tfor (Student s : ts3) &#123;\t\tSystem.out.println(s.getName() + &quot;---&quot; + s.getAge());\t&#125;\tSystem.out.println(&quot;----------------------------&quot;);\t 参数中直接创建接口的实现内部类；实现Comparator接口的方法\tTreeSet&lt;String&gt; ts1 = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;\t\t@Override\t\tpublic int compare(String o1, String o2) &#123;\t\t\tint i1 = o1.length() - o2.length();\t\t\tint i2 = i1 == 0 ? o1.compareTo(o2) : i1;\t\t\treturn i2;\t\t&#125;\t&#125;);\tts1.add(&quot;第一个&quot;);\tts1.add(&quot;第二个&quot;);\tts1.add(&quot;第三个&quot;);\tts1.add(&quot;第四个&quot;);\tfor (String s : ts1) &#123;\t\tSystem.out.println(s);\t&#125;&#125;*输出结果    第一个\t第三个\t第二个\t----------------------------\t张三---12\t赵六---12\t张三---19\t王五---20\t李四---50\t----------------------------\t四眼---12\t张三---12\t张三---19\t王五---20\t李四---50\t----------------------------\t第一个\t第三个\t第二个\t第四个*\nCollection&lt; E &gt;简单总结\n\nCollection&lt; E &gt;\n单列集合类型，只能存储引用类型数据，为接口，具体使用需要用实现子类。\n下面介绍的按其继承关系排列。\n\n\nList&lt; E &gt;：元素有序，可重复\n\nArrayList&lt; E &gt;：增删慢，查找快；底层使用数组，线程不安全，效率高\nVector&lt; E &gt;：增删满，查找快；底层使用数组，线程安全，效率低\nLinkedList&lt; E &gt;：增删快，查找慢；底层使用链表\n\n\nSet&lt; E &gt;：元素无序，不重复\n\nHashSet&lt; E &gt;：集合元素有序，底层使用哈希表，依靠hashCode()和equals()方法，保证元素唯\n\nLinkedHashSet&lt; E &gt;：底层是链表和哈希表(链表保证有序，哈希表保证唯一)\n\n\nTreeSet&lt; E &gt;：底层使用自平衡二叉树，有两种排序方案：自然排序(Comparable)、比较器排序(Comparator)，保证唯一依赖的是排序方法的返回值，0表示元素重复。\n\n\n\nMap&lt;K,V &gt;\n\n简述\n类型：interface；继承：Object\n该集合是一种将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。Map的数据结构与键有关，是双列结构。\n该接口的常用实现子类：HashMap&lt;K,V&gt;、LinkHashMap&lt;K,V&gt;和TreeMap&lt;K,V&gt;。\n方法介绍\n接口仅对方法进行定义。\n\n\n添加功能\n\n\nV put(K key,V value) —— 添加修改键值对元素，键如果存在则将旧值替换，不存在则直接添加元素。\nvoid putAll(Map&lt;? extends K&gt;,&lt;? extends V&gt; m) —— 将源集合添加至目标集合。\n\n\n删除功能\n\n\nvoid clear() —— 清除目标集合中的所有键值对元素。\nV remove(Object key) —— 移除指定键对应的元素，返回被移除的值，不存在返回null。\n\n\n判断功能\n\n\nboolean containsKey(Object key) —— 判断该键在目标集合中是否存在。\nboolean containsValue(Object value) —— 判断指定的值在目标集合中是否存在。\nboolean isEmpty() —— 判断该集合是否为空。\n\n\n获取功能\n\n\nV get(Object key) —— 得到指定键映射的值。\nCollection values() —— 返回此映射中包含的值的 Collection 视图\nSet keySet() —— 返回此映射中包含的键的 Set 集合视图\nSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() —— 返回此映射中包含映射关系的 Set 集合视图。[2]\n\n\n长度功能\n\n\nint size() —— 得到集合元素的大小。\n\n\n代码演示\nMap&lt;K,V&gt;是一种双列集合，并且其中键是唯一的。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args)&#123;\t创建Map集合,接口不能创建对象\tMap&lt;String,String&gt; m = new HashMap&lt;&gt;();\t添加元素，如果集合中元素键已存在，新的元素值将会替换\tm.put(&quot;火警&quot;,&quot;119&quot;);\tm.put(&quot;急救&quot;,&quot;120&quot;);\tm.put(&quot;匪警&quot;,&quot;110&quot;);\tm.put(&quot;火警&quot;,&quot;未知&quot;);\tm.put(null, null);\t清除集合元素\tm.clear();\tm.remove(&quot;火警&quot;);\t判断指定键是否存在集合中\tSystem.out.println(&quot;判断急救在集合中：&quot; + m.containsKey(&quot;急救&quot;));\tSystem.out.println(&quot;判断120在集合中：&quot; + m.containsValue(&quot;120&quot;));\tSystem.out.println(&quot;判断集合是否为空：&quot; + m.isEmpty());\tSystem.out.println(&quot;得到集合的键值对数量：&quot; + m.size());\t得到指定键的值\tSystem.out.println(&quot;获取键为匪警的值：&quot; + m.get(&quot;匪警&quot;));\t得到集合的所有键\tSet&lt;String&gt; s = m.keySet();\tfor(String ss : s)&#123;\t\tSystem.out.println(ss + &quot;、&quot;);\t&#125;\t得到集合的所有值\tCollection&lt;String&gt; c = m.values();\tfor(String a : c)&#123;\t\tSystem.out.println(a);\t&#125;\t获取集合的键值对\tSet&lt;Map.Entry&lt;String,String&gt;&gt; set = m.entrySet();\tfor(Map.Entry&lt;String,String&gt; me : set)&#123;\t\tSystem.out.println(me.getKey() + &quot;---&quot; + me.getValue());\t&#125;\tSystem.out.println(m);&#125;*输出结果    判断急救在集合中：true\t判断120在集合中：true\t判断集合是否为空：false\t得到集合的键值对数量：3\t获取键为匪警的值：110\t急救、\tnull、\t匪警、\t120\tnull\t110\t急救---120\tnull---null\t匪警---110\t&#123;急救=120, null=null, 匪警=110&#125;*\nHashMap&lt;K,V&gt;\n\n简述\n类型：实体类；继承：AbstractMap&lt;K,V&gt;\n实现：Map&lt;K,V&gt;, Cloneable, Serializable\nAbstractMap&lt;K,V&gt;：类型：Abstract；实现：Map&lt;K,V&gt;\n基于哈希表的 Map&lt;K,V&gt; 接口的实现。此实现允许使用 null 值和 null 键；但不保证集合的顺序，特别是它不保证该顺序恒久不变。\n方法介绍\n没有新增方法，均为继承与实现方法的重写。\n代码演示\n略…\n\nLinkedHashMap&lt;K,V&gt;\n\n简述\n类型：实现类；继承：HashMap&lt;K,V&gt;\n实现： Map&lt;K,V&gt;\nLinkHashMap&lt;K,V&gt;是通过哈希表和链表实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链表定义了集合迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。\n方法介绍\n没有新增方法，均为继承与实现方法的重写。\n代码演示\n略…\n\nTreeMap&lt;K,V&gt;\n\n简述\n基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。如果是存储自定义对象，这是就要在元素所属的类中实现自然排序接口，或者使用有参的构造方法实现比较器排序\n方法介绍\n很多的新增方法，但是一般不常用，需要了解，查看JAVA API\n代码演示\nTreeMap&lt;K,V&gt;是基于二叉树的数据结构存储元素集合。\n\n1234567891011121314151617181920212223242526static void treeMaps()&#123;\tTreeMap&lt;Student,Integer&gt; ts = new TreeMap&lt;&gt;();\tts.put(new Student(&quot;张三&quot;,15),101);\tts.put(new Student(&quot;李四&quot;,10),102);\tts.put(new Student(&quot;王五&quot;,46),103);\tts.put(new Student(&quot;张三&quot;,45),104);\tts.put(new Student(&quot;赵六&quot;,85),105);\tSet&lt;Map.Entry&lt;Student,Integer&gt;&gt; s = ts.entrySet();\tfor(Map.Entry&lt;Student,Integer&gt; m : s)&#123;\t\tStudent st = m.getKey();\t\tSystem.out.println(st.getName()+ &quot;---&quot; + st.getAge()+ &quot;---&quot;+ m.getValue());\t&#125;\t通过键获取一个键-值映射关系\tMap.Entry&lt;Student,Integer&gt; en = ts.ceilingEntry(new Student(&quot;张三&quot;,15));\tSystem.out.println(en.getKey().getName()+en.getValue());&#125;*输出结果\t李四---10---102\t张三---15---101\t张三---45---104\t王五---46---103\t赵六---85---105\t张三101*\nMap&lt;K,V&gt;简单总结\n\nMap&lt;K,V&gt;\n这是双列集合，采用键值对的方式，数据结构与键有关，与值无关。\n\n\nHashMap&lt;K,V&gt;：采用哈希表保证元素的唯一性，但是集合元素不保证有序，必须实现hashCode()和equals()。\n-LinkedHashMap&lt;K,V&gt;：采用链表加哈希表的数据结构，用链表保证有序，哈希表保证元素唯一。\nTreeMap&lt;K,V&gt;：采用红黑树数据结构保证元素的唯一性；该种集合，元素对象所属类需要实现Comparable接口或集合构造方法参数是一个比较器排序的对象Comparator。\n\n\nCollections集合工具\n\n简述\n类名：Collections；\n作用：此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。\n方法：Collections该类提供了静态方法。\n方法介绍\n集合对象直接使用静态方法。\n\n\nvoid sort(List list) —— 默认情况是自然排序，集合元素所属的类必须实现自然排序接口才可以使用此方法。\nint binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) —— 使用二分搜索法搜索指定列表，以获得指定对象。\nvoid swap(List&lt;?&gt; list, int i, int j) —— 在指定列表的指定位置处交换元素。\nCollection synchronizedCollection(Collection c) —— 返回指定 collection 支持的同步（线程安全的）collection。\n还有其他获取同步类型的集合…\nboolean replaceAll(List list, T oldVal, T newVal) —— 使用另一个值替换列表中出现的所有某一指定值。\n max(Collecton&lt;&lt;? extends T&gt; coll) —— 根据元素的自然顺序，返回给定 collection 的最大元素。\nvoid reverse(List&lt;?&gt; list) —— 反转指定列表中元素的顺序。\nvoid shuffle(List&lt;?&gt; list) —— 使用默认随机源对指定列表进行置换。\n\n还有更多的方法可以方便的对集合对象操作\n\n小结\nCollections工具类可以方便的对集合元素操作。\n例如：元素的替换、集合的排序、元素的查找等\n\n\n更多 Java__集合 方法学习参考 JAVA API\n\n\n\nIterator对象：\n方法：boolean hasNext()，E next()，void remove()。\nhasNext()：如果迭代后面仍有元素，返回true。\nnext()：返回迭代的下一个元素，并同时指向下一个元素。\nremove()：从集合中移除迭代器返的最后一个元素,每调用一次next仅可以用一次该方法。\nIterator接口方法是在实现类中通过内部类实现，以此来针对不同的数据组织形式，编写hasNext(),next()和remove()方法。\n迭代器是依赖于集合存在的，如果在使用迭代器的时候，使用集合方法修改元素，这时迭代器并不能发现集合元素的变化，所以就会报错：\n【ConcurrentModificationException：当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。】\nA: 有时就是需要在遍历时添加元素，这时就需要解决这种异常错误，有两种方法；\n在使用迭代器遍历时，用迭代器提供的方法修改元素，但是在Iterator中并没有提供添加元素的方法，这就需要用到ListIterator接口提供的方法（注意：只有在List集合中存在该接口）。\nB: 使用集合遍历元素，利用集合提供的方法修改元素（普通for循环方式）。\n不允许既使用迭代器又使用集合。 ↩ ↩\n\nMap.Entry&lt;K,V&gt;：这是一种键值对实体对象，提供了获取键和值的方法：getKey()、getValue()，在对集合进行键值对遍历时可以使用这种方法，也可以使用键找值的方法遍历。 ↩\n\n\n\n","tags":["java","集合","Collection","Map"],"path":"2018/06/16/JAVA+集合/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
更多分类：
	<a href="/tags/Coding/" style="font-size: 0.8em; color: #488baf">Coding</a> <a href="/tags/Collection/" style="font-size: 0.8em; color: #488baf">Collection</a> <a href="/tags/HEXO/" style="font-size: 0.8em; color: #488baf">HEXO</a> <a href="/tags/Map/" style="font-size: 0.8em; color: #488baf">Map</a> <a href="/tags/github/" style="font-size: 0.8em; color: #488baf">github</a> <a href="/tags/java/" style="font-size: 0.8em; color: #488baf">java</a> <a href="/tags/搭建博客/" style="font-size: 0.8em; color: #488baf">搭建博客</a> <a href="/tags/集合/" style="font-size: 0.8em; color: #488baf">集合</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> 版权所有 <a href="">Mr.Liu </a> @ 2018</p>
            <p>设计: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> 和 <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; 主题: <a href="http://www.itlzb.cn/">Cutie 2.1.0-Taurus</a> &bull; 由 <a href="http://hexo.io">Hexo.</a> 强力驱动</p>
        </div>
    </div>
    
    <div class='footer-social'>
        
            
                
                    <div class='footer-social-item'><a href='https://github.com/ITliuzhaobiao' target='_blank' ><i class="fab fa-github fa-2x" aria-hidden="true"></i></a></div>
                
            
                
                    <div class='footer-social-item'><a href='https://weibo.com/eryuxinsheng' target='_blank' ><i class="fab fa-weibo fa-2x" aria-hidden="true"></i></a></div>
                
            
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
		
			
				
			
		
		
	
		
			
		
		
	
		
			
		
		
	
		
			
		
		
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/colorful-outlined/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/colorful-outlined/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/colorful-outlined/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
			
			
				
			
				
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/CV/index.html">
							<span>C v</span>
						</a>
					</div>
			</div>
		
		
			
			
				
			
				
					
				
			
		
		
			
			
				
			
				
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/categories/简生活/">
							<span>简生活</span>
						</a>
					</div>
			</div>
		
		
			
			
				
					
				
			
				
			
		
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/闲杂随笔/">
						<span>闲杂随笔</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/以梦为马/">
						<span>以梦为马</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    







    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
